{"ast":null,"code":"module.exports = /******/function (modules) {\n  // webpackBootstrap\n  /******/ // The module cache\n  /******/\n  var installedModules = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __webpack_require__(moduleId) {\n    /******/\n    /******/ // Check if module is in cache\n    /******/if (installedModules[moduleId]) {\n      /******/return installedModules[moduleId].exports;\n      /******/\n    }\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = installedModules[moduleId] = {\n      /******/i: moduleId,\n      /******/l: false,\n      /******/exports: {}\n      /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    /******/ // Flag the module as loaded\n    /******/\n    module.l = true;\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /******/\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/\n  __webpack_require__.m = modules;\n  /******/\n  /******/ // expose the module cache\n  /******/\n  __webpack_require__.c = installedModules;\n  /******/\n  /******/ // define getter function for harmony exports\n  /******/\n  __webpack_require__.d = function (exports, name, getter) {\n    /******/if (!__webpack_require__.o(exports, name)) {\n      /******/Object.defineProperty(exports, name, {\n        enumerable: true,\n        get: getter\n      });\n      /******/\n    }\n    /******/\n  };\n  /******/\n  /******/ // define __esModule on exports\n  /******/\n  __webpack_require__.r = function (exports) {\n    /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      /******/Object.defineProperty(exports, Symbol.toStringTag, {\n        value: 'Module'\n      });\n      /******/\n    }\n    /******/\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    /******/\n  };\n  /******/\n  /******/ // create a fake namespace object\n  /******/ // mode & 1: value is a module id, require it\n  /******/ // mode & 2: merge all properties of value into the ns\n  /******/ // mode & 4: return value when already ns object\n  /******/ // mode & 8|1: behave like require\n  /******/\n  __webpack_require__.t = function (value, mode) {\n    /******/if (mode & 1) value = __webpack_require__(value);\n    /******/\n    if (mode & 8) return value;\n    /******/\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n    /******/\n    var ns = Object.create(null);\n    /******/\n    __webpack_require__.r(ns);\n    /******/\n    Object.defineProperty(ns, 'default', {\n      enumerable: true,\n      value: value\n    });\n    /******/\n    if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n      return value[key];\n    }.bind(null, key));\n    /******/\n    return ns;\n    /******/\n  };\n  /******/\n  /******/ // getDefaultExport function for compatibility with non-harmony modules\n  /******/\n  __webpack_require__.n = function (module) {\n    /******/var getter = module && module.__esModule ? /******/function getDefault() {\n      return module['default'];\n    } : /******/function getModuleExports() {\n      return module;\n    };\n    /******/\n    __webpack_require__.d(getter, 'a', getter);\n    /******/\n    return getter;\n    /******/\n  };\n  /******/\n  /******/ // Object.prototype.hasOwnProperty.call\n  /******/\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  /******/\n  /******/ // __webpack_public_path__\n  /******/\n  __webpack_require__.p = \"\";\n  /******/\n  /******/\n  /******/ // Load entry module and return exports\n  /******/\n  return __webpack_require__(__webpack_require__.s = 19);\n  /******/\n}\n/************************************************************************/\n/******/([/* 0 */\n/***/function (module, exports) {\n  module.exports = require(\"react\");\n\n  /***/\n}, /* 1 */\n/***/function (module, exports) {\n  module.exports = require(\"papaparse\");\n\n  /***/\n}, /* 2 */\n/***/function (module, exports) {\n  module.exports = require(\"react-dropzone\");\n\n  /***/\n}, /* 3 */\n/***/function (module, exports) {\n  module.exports = require(\"react-use-gesture\");\n\n  /***/\n}, /* 4 */\n/***/function (module, exports) {\n  module.exports = require(\"react-dom\");\n\n  /***/\n}, /* 5 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 6 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 7 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 8 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 9 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 10 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 11 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 12 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 13 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 14 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 15 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 16 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 17 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 18 */\n/***/function (module, exports, __webpack_require__) {\n\n  // extracted by mini-css-extract-plugin\n\n  /***/}, /* 19 */\n/***/function (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n\n  // ESM COMPAT FLAG\n  __webpack_require__.r(__webpack_exports__);\n\n  // EXPORTS\n  __webpack_require__.d(__webpack_exports__, \"ImporterField\", function () {\n    return (/* reexport */ImporterField\n    );\n  });\n  __webpack_require__.d(__webpack_exports__, \"Importer\", function () {\n    return (/* reexport */Importer_Importer\n    );\n  });\n  __webpack_require__.d(__webpack_exports__, \"enUS\", function () {\n    return (/* reexport */enUS\n    );\n  });\n  __webpack_require__.d(__webpack_exports__, \"deDE\", function () {\n    return (/* reexport */deDE\n    );\n  });\n\n  // CONCATENATED MODULE: ./src/components/ImporterProps.ts\n\n  // EXTERNAL MODULE: external \"react\"\n  var external_react_ = __webpack_require__(0);\n  var external_react_default = /*#__PURE__*/__webpack_require__.n(external_react_);\n\n  // EXTERNAL MODULE: external \"papaparse\"\n  var external_papaparse_ = __webpack_require__(1);\n  var external_papaparse_default = /*#__PURE__*/__webpack_require__.n(external_papaparse_);\n\n  // CONCATENATED MODULE: ./src/parser.ts\n  var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P ? value : new P(function (resolve) {\n        resolve(value);\n      });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\n  const PREVIEW_ROW_COUNT = 5;\n  // polyfill as implemented in https://github.com/eligrey/Blob.js/blob/master/Blob.js#L653\n  // (this is for Safari pre v14.1)\n  function streamForBlob(blob) {\n    if (blob.stream) {\n      return blob.stream();\n    }\n    const res = new Response(blob);\n    if (res.body) {\n      return res.body;\n    }\n    throw new Error('This browser does not support client-side file reads');\n  }\n  // incredibly cheap wrapper exposing a subset of stream.Readable interface just for PapaParse usage\n  // @todo chunk size\n  function nodeStreamWrapper(stream, encoding) {\n    let dataHandler = null;\n    let endHandler = null;\n    let errorHandler = null;\n    let isStopped = false;\n    let pausePromise = null;\n    let pauseResolver = null;\n    function runReaderPump() {\n      return __awaiter(this, void 0, void 0, function* () {\n        // ensure this is truly in the next tick after uncorking\n        yield Promise.resolve();\n        const streamReader = stream.getReader();\n        const decoder = new TextDecoder(encoding); // this also strips BOM by default\n        try {\n          // main reader pump loop\n          while (!isStopped) {\n            // perform read from upstream\n            const {\n              done,\n              value\n            } = yield streamReader.read();\n            // wait if we became paused since last data event\n            if (pausePromise) {\n              yield pausePromise;\n            }\n            // check again if stopped and unlistened\n            if (isStopped || !dataHandler || !endHandler) {\n              return;\n            }\n            // final data flush and end notification\n            if (done) {\n              const lastChunkString = decoder.decode(value); // value is empty but pass just in case\n              if (lastChunkString) {\n                dataHandler(lastChunkString);\n              }\n              endHandler(undefined);\n              return;\n            }\n            // otherwise, normal data event after stream-safe decoding\n            const chunkString = decoder.decode(value, {\n              stream: true\n            });\n            dataHandler(chunkString);\n          }\n        } finally {\n          // always release the lock\n          streamReader.releaseLock();\n        }\n      });\n    }\n    const self = {\n      // marker properties to make PapaParse think this is a Readable object\n      readable: true,\n      read() {\n        throw new Error('only flowing mode is emulated');\n      },\n      on(event, callback) {\n        switch (event) {\n          case 'data':\n            if (dataHandler) {\n              throw new Error('two data handlers not supported');\n            }\n            dataHandler = callback;\n            // flowing state started, run the main pump loop\n            runReaderPump().catch(error => {\n              if (errorHandler) {\n                errorHandler(error);\n              } else {\n                // rethrow to show error in console\n                throw error;\n              }\n            });\n            return;\n          case 'end':\n            if (endHandler) {\n              throw new Error('two end handlers not supported');\n            }\n            endHandler = callback;\n            return;\n          case 'error':\n            if (errorHandler) {\n              throw new Error('two error handlers not supported');\n            }\n            errorHandler = callback;\n            return;\n        }\n        throw new Error('unknown stream shim event: ' + event);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      removeListener(event, callback) {\n        // stop and clear everything for simplicity\n        isStopped = true;\n        dataHandler = null;\n        endHandler = null;\n        errorHandler = null;\n      },\n      pause() {\n        if (!pausePromise) {\n          pausePromise = new Promise(resolve => {\n            pauseResolver = resolve;\n          });\n        }\n        return self;\n      },\n      resume() {\n        if (pauseResolver) {\n          pauseResolver(); // waiting code will proceed in next tick\n          pausePromise = null;\n          pauseResolver = null;\n        }\n        return self;\n      }\n    };\n    // pass ourselves off as a real Node stream\n    return self;\n  }\n  function parsePreview(file, customConfig) {\n    // wrap synchronous errors in promise\n    return new Promise(resolve => {\n      let firstChunk = null;\n      let firstWarning = undefined;\n      const rowAccumulator = [];\n      function reportSuccess() {\n        // PapaParse normally complains first anyway, but might as well flag it\n        if (rowAccumulator.length === 0) {\n          return {\n            parseError: new Error('File is empty'),\n            file\n          };\n        }\n        // remember whether this file has only one line\n        const isSingleLine = rowAccumulator.length === 1;\n        // fill preview with blanks if needed\n        while (rowAccumulator.length < PREVIEW_ROW_COUNT) {\n          rowAccumulator.push([]);\n        }\n        resolve({\n          file,\n          parseError: undefined,\n          parseWarning: firstWarning || undefined,\n          firstChunk: firstChunk || '',\n          firstRows: rowAccumulator,\n          isSingleLine\n        });\n      }\n      // use our own multibyte-safe streamer, bail after first chunk\n      // (this used to add skipEmptyLines but that was hiding possible parse errors)\n      // @todo wait for upstream multibyte fix in PapaParse: https://github.com/mholt/PapaParse/issues/908\n      const nodeStream = nodeStreamWrapper(streamForBlob(file), customConfig.encoding || 'utf-8');\n      external_papaparse_default.a.parse(nodeStream, Object.assign(Object.assign({}, customConfig), {\n        chunkSize: 10000,\n        preview: PREVIEW_ROW_COUNT,\n        error: error => {\n          resolve({\n            parseError: error,\n            file\n          });\n        },\n        beforeFirstChunk: chunk => {\n          firstChunk = chunk;\n        },\n        chunk: (_ref, parser) => {\n          let {\n            data,\n            errors\n          } = _ref;\n          data.forEach(row => {\n            const stringRow = row.map(item => typeof item === 'string' ? item : '');\n            rowAccumulator.push(stringRow);\n          });\n          if (errors.length > 0 && !firstWarning) {\n            firstWarning = errors[0];\n          }\n          // finish parsing once we got enough data, otherwise try for more\n          // (in some cases PapaParse flushes out last line as separate chunk)\n          if (rowAccumulator.length >= PREVIEW_ROW_COUNT) {\n            nodeStream.pause(); // parser does not pause source stream, do it here explicitly\n            parser.abort();\n            reportSuccess();\n          }\n        },\n        complete: reportSuccess\n      }));\n    }).catch(error => {\n      return {\n        parseError: error,\n        file\n      };\n    });\n  }\n  function processFile(input, reportProgress, callback) {\n    const {\n      file,\n      hasHeaders,\n      papaParseConfig,\n      fieldAssignments\n    } = input;\n    const fieldNames = Object.keys(fieldAssignments);\n    // wrap synchronous errors in promise\n    return new Promise((resolve, reject) => {\n      // skip first line if needed\n      let skipLine = hasHeaders;\n      let processedCount = 0;\n      // use our own multibyte-safe decoding streamer\n      // @todo wait for upstream multibyte fix in PapaParse: https://github.com/mholt/PapaParse/issues/908\n      const nodeStream = nodeStreamWrapper(streamForBlob(file), papaParseConfig.encoding || 'utf-8');\n      external_papaparse_default.a.parse(nodeStream, Object.assign(Object.assign({}, papaParseConfig), {\n        chunkSize: papaParseConfig.chunkSize || 10000,\n        error: error => {\n          reject(error);\n        },\n        chunk: (_ref2, parser) => {\n          let {\n            data\n          } = _ref2;\n          // pause to wait until the rows are consumed\n          nodeStream.pause(); // parser does not pause source stream, do it here explicitly\n          parser.pause();\n          const skipped = skipLine && data.length > 0;\n          const rows = (skipped ? data.slice(1) : data).map(row => {\n            const stringRow = row.map(item => typeof item === 'string' ? item : '');\n            const record = {};\n            fieldNames.forEach(fieldName => {\n              const columnIndex = fieldAssignments[fieldName];\n              if (columnIndex !== undefined) {\n                record[fieldName] = stringRow[columnIndex];\n              }\n            });\n            return record; // @todo look into a more precise setup\n          });\n          // clear line skip flag if there was anything to skip\n          if (skipped) {\n            skipLine = false;\n          }\n          // info snapshot for processing callback\n          const info = {\n            startIndex: processedCount\n          };\n          processedCount += rows.length;\n          // @todo collect errors\n          reportProgress(rows.length);\n          // wrap sync errors in promise\n          // (avoid invoking callback if there are no rows to consume)\n          const whenConsumed = new Promise(resolve => {\n            const result = rows.length ? callback(rows, info) : undefined;\n            // introduce delay to allow a frame render\n            setTimeout(() => resolve(result), 0);\n          });\n          // unpause parsing when done\n          whenConsumed.then(() => {\n            nodeStream.resume();\n            parser.resume();\n          }, () => {\n            // @todo collect errors\n            nodeStream.resume();\n            parser.resume();\n          });\n        },\n        complete: () => {\n          resolve();\n        }\n      }));\n    });\n  }\n\n  // EXTERNAL MODULE: ./src/components/TextButton.scss\n  var TextButton = __webpack_require__(5);\n\n  // CONCATENATED MODULE: ./src/components/TextButton.tsx\n\n  const TextButton_TextButton = _ref3 => {\n    let {\n      disabled,\n      onClick,\n      children\n    } = _ref3;\n    return external_react_default.a.createElement(\"button\", {\n      className: \"CSVImporter_TextButton\",\n      disabled: disabled,\n      onClick: onClick\n    }, children);\n  };\n\n  // EXTERNAL MODULE: ./src/components/IconButton.scss\n  var IconButton = __webpack_require__(6);\n\n  // CONCATENATED MODULE: ./src/components/IconButton.tsx\n\n  const IconButton_IconButton = _ref4 => {\n    let {\n      type,\n      label,\n      small,\n      focusOnly,\n      disabled,\n      onClick\n    } = _ref4;\n    return external_react_default.a.createElement(\"button\", {\n      className: \"CSVImporter_IconButton\",\n      \"aria-label\": label,\n      disabled: disabled,\n      onClick: onClick,\n      \"data-small\": !!small,\n      \"data-focus-only\": !!focusOnly\n    }, external_react_default.a.createElement(\"span\", {\n      \"data-type\": type\n    }));\n  };\n\n  // EXTERNAL MODULE: ./src/components/ImporterFrame.scss\n  var ImporterFrame = __webpack_require__(7);\n\n  // CONCATENATED MODULE: ./src/locale/index.ts\n  /* eslint-disable @typescript-eslint/explicit-module-boundary-types -- all exports are ImporterLocale which is already fully typed */\n  const enUS = {\n    general: {\n      goToPreviousStepTooltip: 'Go to previous step'\n    },\n    fileStep: {\n      initialDragDropPrompt: 'Drag-and-drop CSV file here, or click to select in folder',\n      activeDragDropPrompt: 'Drop CSV file here...',\n      getImportError: message => `Import error: ${message}`,\n      getDataFormatError: message => `Please check data formatting: ${message}`,\n      goBackButton: 'Go Back',\n      nextButton: 'Choose columns',\n      rawFileContentsHeading: 'Raw File Contents',\n      previewImportHeading: 'Preview Import',\n      dataHasHeadersCheckbox: 'Data has headers',\n      previewLoadingStatus: 'Loading preview...'\n    },\n    fieldsStep: {\n      stepSubtitle: 'Select Columns',\n      requiredFieldsError: 'Please assign all required fields',\n      nextButton: 'Import',\n      dragSourceAreaCaption: 'Columns to import',\n      getDragSourcePageIndicator: (currentPage, pageCount) => `Page ${currentPage} of ${pageCount}`,\n      getDragSourceActiveStatus: columnCode => `Assigning column ${columnCode}`,\n      nextColumnsTooltip: 'Show next columns',\n      previousColumnsTooltip: 'Show previous columns',\n      clearAssignmentTooltip: 'Clear column assignment',\n      selectColumnTooltip: 'Select column for assignment',\n      unselectColumnTooltip: 'Unselect column',\n      dragTargetAreaCaption: 'Target fields',\n      getDragTargetOptionalCaption: field => `${field} (optional)`,\n      getDragTargetRequiredCaption: field => `${field} (required)`,\n      dragTargetPlaceholder: 'Drag column here',\n      getDragTargetAssignTooltip: columnCode => `Assign column ${columnCode}`,\n      dragTargetClearTooltip: 'Clear column assignment',\n      columnCardDummyHeader: 'Unassigned field',\n      getColumnCardHeader: code => `Column ${code}`\n    },\n    progressStep: {\n      stepSubtitle: 'Import',\n      uploadMoreButton: 'Upload More',\n      finishButton: 'Finish',\n      statusError: 'Could not import',\n      statusComplete: 'Complete',\n      statusPending: 'Importing...',\n      processedRowsLabel: 'Processed rows:'\n    }\n  };\n  const deDE = {\n    general: {\n      goToPreviousStepTooltip: 'Zum vorherigen Schritt'\n    },\n    fileStep: {\n      initialDragDropPrompt: 'CSV-Datei auf dieses Feld ziehen, oder klicken um eine Datei auszuwählen',\n      activeDragDropPrompt: 'CSV-Datei auf dieses Feld ziehen...',\n      nextButton: 'Spalten auswählen',\n      getImportError: message => `Fehler beim Import: ${message}`,\n      getDataFormatError: message => `Bitte Datenformat überprüfen: ${message}`,\n      goBackButton: 'Zurück',\n      rawFileContentsHeading: 'Originaler Datei-Inhalt',\n      previewImportHeading: 'Import-Vorschau',\n      dataHasHeadersCheckbox: 'Mit Kopfzeile',\n      previewLoadingStatus: 'Vorschau wird geladen...'\n    },\n    fieldsStep: {\n      stepSubtitle: 'Spalten auswählen',\n      requiredFieldsError: 'Bitte weise allen nicht optionalen Spalten einen Wert zu',\n      nextButton: 'Importieren',\n      dragSourceAreaCaption: 'Zu importierende Spalte',\n      getDragSourcePageIndicator: (currentPage, pageCount) => `Seite ${currentPage} von ${pageCount}`,\n      getDragSourceActiveStatus: columnCode => `Spalte ${columnCode} zuweisen`,\n      nextColumnsTooltip: 'Nächste Spalten anzeigen',\n      previousColumnsTooltip: 'Vorherige Spalten anzeigen',\n      clearAssignmentTooltip: 'Zugewiesene Spalte entfernen',\n      selectColumnTooltip: 'Spalte zum Zuweisen auswählen',\n      unselectColumnTooltip: 'Spalte abwählen',\n      dragTargetAreaCaption: 'Zielfelder',\n      getDragTargetOptionalCaption: field => `${field} (optional)`,\n      getDragTargetRequiredCaption: field => `${field} (erforderlich)`,\n      dragTargetPlaceholder: 'Spalte hierher ziehen',\n      getDragTargetAssignTooltip: columnCode => `Spalte ${columnCode} zuweisen`,\n      dragTargetClearTooltip: 'Zugewiesene Spalte entfernen',\n      columnCardDummyHeader: 'Nicht zugewiesenes Feld',\n      getColumnCardHeader: code => `Spalte ${code}`\n    },\n    progressStep: {\n      stepSubtitle: 'Importieren',\n      uploadMoreButton: 'Weitere hochladen',\n      finishButton: 'Abschließen',\n      statusError: 'Konnte nicht importiert werden',\n      statusComplete: 'Fertig',\n      statusPending: 'Wird importiert...',\n      processedRowsLabel: 'Verarbeitete Zeilen:'\n    }\n  };\n\n  // CONCATENATED MODULE: ./src/locale/LocaleContext.tsx\n\n  const LocaleContext = external_react_default.a.createContext(enUS);\n  function useLocale(namespace) {\n    const locale = Object(external_react_[\"useContext\"])(LocaleContext);\n    return locale[namespace]; // not using memo for basic property getter\n  }\n\n  // CONCATENATED MODULE: ./src/components/ImporterFrame.tsx\n\n  const ImporterFrame_ImporterFrame = _ref5 => {\n    let {\n      fileName,\n      subtitle,\n      secondaryDisabled,\n      secondaryLabel,\n      nextDisabled,\n      nextLabel,\n      error,\n      onSecondary,\n      onNext,\n      onCancel,\n      children\n    } = _ref5;\n    const titleRef = Object(external_react_[\"useRef\"])(null);\n    const subtitleRef = Object(external_react_[\"useRef\"])(null);\n    Object(external_react_[\"useEffect\"])(() => {\n      if (subtitleRef.current) {\n        subtitleRef.current.focus();\n      } else if (titleRef.current) {\n        titleRef.current.focus();\n      }\n    }, []);\n    const l10n = useLocale('general');\n    return external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame\"\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__header\"\n    }, external_react_default.a.createElement(IconButton_IconButton, {\n      label: l10n.goToPreviousStepTooltip,\n      type: \"arrowBack\",\n      disabled: !onCancel,\n      onClick: onCancel\n    }), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__headerTitle\",\n      tabIndex: -1,\n      ref: titleRef\n    }, fileName), subtitle ? external_react_default.a.createElement(external_react_default.a.Fragment, null, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__headerCrumbSeparator\"\n    }, external_react_default.a.createElement(\"span\", null)), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__headerSubtitle\",\n      tabIndex: -1,\n      ref: subtitleRef\n    }, subtitle)) : null), children, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__footer\"\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__footerFill\"\n    }), error ? external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__footerError\",\n      role: \"status\"\n    }, error) : null, secondaryLabel ? external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__footerSecondary\"\n    }, external_react_default.a.createElement(TextButton_TextButton, {\n      disabled: !!secondaryDisabled,\n      onClick: onSecondary\n    }, secondaryLabel)) : null, nextLabel !== false ? external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__footerNext\"\n    }, external_react_default.a.createElement(TextButton_TextButton, {\n      disabled: !!nextDisabled,\n      onClick: onNext\n    }, nextLabel)) : null));\n  };\n\n  // EXTERNAL MODULE: external \"react-dropzone\"\n  var external_react_dropzone_ = __webpack_require__(2);\n\n  // EXTERNAL MODULE: ./src/components/file-step/FileSelector.scss\n  var FileSelector = __webpack_require__(8);\n\n  // CONCATENATED MODULE: ./src/components/file-step/FileSelector.tsx\n\n  const FileSelector_FileSelector = _ref6 => {\n    let {\n      onSelected\n    } = _ref6;\n    const onSelectedRef = Object(external_react_[\"useRef\"])(onSelected);\n    onSelectedRef.current = onSelected;\n    const dropHandler = Object(external_react_[\"useCallback\"])(acceptedFiles => {\n      // silently ignore if nothing to do\n      if (acceptedFiles.length < 1) {\n        return;\n      }\n      const file = acceptedFiles[0];\n      onSelectedRef.current(file);\n    }, []);\n    const {\n      getRootProps,\n      getInputProps,\n      isDragActive\n    } = Object(external_react_dropzone_[\"useDropzone\"])({\n      onDrop: dropHandler\n    });\n    const l10n = useLocale('fileStep');\n    return external_react_default.a.createElement(\"div\", Object.assign({\n      className: \"CSVImporter_FileSelector\",\n      \"data-active\": !!isDragActive\n    }, getRootProps()), external_react_default.a.createElement(\"input\", Object.assign({}, getInputProps())), isDragActive ? external_react_default.a.createElement(\"span\", null, l10n.activeDragDropPrompt) : external_react_default.a.createElement(\"span\", null, l10n.initialDragDropPrompt));\n  };\n\n  // EXTERNAL MODULE: ./src/components/file-step/FormatErrorMessage.scss\n  var FormatErrorMessage = __webpack_require__(9);\n\n  // CONCATENATED MODULE: ./src/components/file-step/FormatErrorMessage.tsx\n\n  const FormatErrorMessage_FormatErrorMessage = external_react_default.a.memo(_ref7 => {\n    let {\n      onCancelClick,\n      children\n    } = _ref7;\n    const l10n = useLocale('fileStep');\n    return external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_FormatErrorMessage\"\n    }, external_react_default.a.createElement(\"span\", null, children), external_react_default.a.createElement(TextButton_TextButton, {\n      onClick: onCancelClick\n    }, l10n.goBackButton));\n  });\n\n  // EXTERNAL MODULE: ./src/components/file-step/FormatRawPreview.scss\n  var FormatRawPreview = __webpack_require__(10);\n\n  // CONCATENATED MODULE: ./src/components/file-step/FormatRawPreview.tsx\n\n  const RAW_PREVIEW_SIZE = 500;\n  const FormatRawPreview_FormatRawPreview = external_react_default.a.memo(_ref8 => {\n    let {\n      chunk,\n      warning,\n      onCancelClick\n    } = _ref8;\n    const chunkSlice = chunk.slice(0, RAW_PREVIEW_SIZE);\n    const chunkHasMore = chunk.length > RAW_PREVIEW_SIZE;\n    const l10n = useLocale('fileStep');\n    return external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_FormatRawPreview\"\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_FormatRawPreview__scroll\"\n    }, external_react_default.a.createElement(\"pre\", {\n      className: \"CSVImporter_FormatRawPreview__pre\"\n    }, chunkSlice, chunkHasMore && external_react_default.a.createElement(\"aside\", null, \"...\"))), warning ? external_react_default.a.createElement(FormatErrorMessage_FormatErrorMessage, {\n      onCancelClick: onCancelClick\n    }, l10n.getDataFormatError(warning.message || String(warning))) : null);\n  });\n\n  // EXTERNAL MODULE: ./src/components/file-step/FormatDataRowPreview.scss\n  var FormatDataRowPreview = __webpack_require__(11);\n\n  // CONCATENATED MODULE: ./src/components/file-step/FormatDataRowPreview.tsx\n\n  const FormatDataRowPreview_FormatDataRowPreview = external_react_default.a.memo(_ref9 => {\n    let {\n      hasHeaders,\n      rows\n    } = _ref9;\n    const headerRow = hasHeaders ? rows[0] : null;\n    const bodyRows = hasHeaders ? rows.slice(1) : rows;\n    return external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_FormatDataRowPreview\"\n    }, external_react_default.a.createElement(\"table\", {\n      className: \"CSVImporter_FormatDataRowPreview__table\"\n    }, headerRow && external_react_default.a.createElement(\"thead\", null, external_react_default.a.createElement(\"tr\", null, headerRow.map((item, itemIndex) => external_react_default.a.createElement(\"th\", {\n      key: itemIndex\n    }, item)))), external_react_default.a.createElement(\"tbody\", null, bodyRows.map((row, rowIndex) => external_react_default.a.createElement(\"tr\", {\n      key: rowIndex\n    }, row.map((item, itemIndex) => external_react_default.a.createElement(\"td\", {\n      key: itemIndex\n    }, item)))))));\n  });\n\n  // EXTERNAL MODULE: ./src/components/file-step/FileStep.scss\n  var FileStep = __webpack_require__(12);\n\n  // CONCATENATED MODULE: ./src/components/file-step/FileStep.tsx\n\n  const FileStep_FileStep = _ref10 => {\n    let {\n      customConfig,\n      assumeNoHeaders,\n      prevState,\n      onChange,\n      onAccept\n    } = _ref10;\n    // seed from previous state as needed\n    const [selectedFile, setSelectedFile] = Object(external_react_[\"useState\"])(prevState ? prevState.file : null);\n    const [preview, setPreview] = Object(external_react_[\"useState\"])(() => prevState && Object.assign({\n      parseError: undefined\n    }, prevState));\n    const [papaParseConfig, setPapaParseConfig] = Object(external_react_[\"useState\"])(prevState ? prevState.papaParseConfig : customConfig);\n    const [hasHeaders, setHasHeaders] = Object(external_react_[\"useState\"])(prevState ? prevState.hasHeaders : false);\n    // wrap in ref to avoid triggering effect\n    const customConfigRef = Object(external_react_[\"useRef\"])(customConfig);\n    customConfigRef.current = customConfig;\n    const assumeNoHeadersRef = Object(external_react_[\"useRef\"])(assumeNoHeaders);\n    assumeNoHeadersRef.current = assumeNoHeaders;\n    const onChangeRef = Object(external_react_[\"useRef\"])(onChange);\n    onChangeRef.current = onChange;\n    // notify of current state\n    Object(external_react_[\"useEffect\"])(() => {\n      onChangeRef.current(preview && !preview.parseError ? Object.assign(Object.assign({}, preview), {\n        papaParseConfig,\n        hasHeaders\n      }) : null);\n    }, [preview, papaParseConfig, hasHeaders]);\n    // perform async preview parse once for the given file\n    const asyncLockRef = Object(external_react_[\"useRef\"])(0);\n    Object(external_react_[\"useEffect\"])(() => {\n      // clear other state when file selector is reset\n      if (!selectedFile) {\n        setPreview(null);\n        return;\n      }\n      // preserve existing state when parsing for this file is already complete\n      if (preview && preview.file === selectedFile) {\n        return;\n      }\n      const oplock = asyncLockRef.current;\n      // lock in the current PapaParse config instance for use in multiple spots\n      const config = customConfigRef.current;\n      // kick off the preview parse\n      parsePreview(selectedFile, config).then(results => {\n        // ignore if stale\n        if (oplock !== asyncLockRef.current) {\n          return;\n        }\n        // save the results and the original config\n        setPreview(results);\n        setPapaParseConfig(config);\n        // pre-fill headers flag (only possible with >1 lines)\n        setHasHeaders(results.parseError ? false : !assumeNoHeadersRef.current && !results.isSingleLine);\n      });\n      return () => {\n        // invalidate current oplock on change or unmount\n        asyncLockRef.current += 1;\n      };\n    }, [selectedFile, preview]);\n    const l10n = useLocale('fileStep');\n    // clear selected file\n    // preview result content to display\n    const reportBlock = Object(external_react_[\"useMemo\"])(() => {\n      if (!preview) {\n        return null;\n      }\n      if (preview.parseError) {\n        return external_react_default.a.createElement(\"div\", {\n          className: \"CSVImporter_FileStep__mainResultBlock\"\n        }, external_react_default.a.createElement(FormatErrorMessage_FormatErrorMessage, {\n          onCancelClick: () => setSelectedFile(null)\n        }, l10n.getImportError(preview.parseError.message || String(preview.parseError))));\n      }\n      return external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_FileStep__mainResultBlock\"\n      }, external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_FileStep__header\"\n      }, l10n.rawFileContentsHeading), external_react_default.a.createElement(FormatRawPreview_FormatRawPreview, {\n        chunk: preview.firstChunk,\n        warning: preview.parseWarning,\n        onCancelClick: () => setSelectedFile(null)\n      }), preview.parseWarning ? null : external_react_default.a.createElement(external_react_default.a.Fragment, null, external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_FileStep__header\"\n      }, l10n.previewImportHeading, !preview.isSingleLine &&\n      // hide setting if only one line anyway\n      external_react_default.a.createElement(\"label\", {\n        className: \"CSVImporter_FileStep__headerToggle\"\n      }, external_react_default.a.createElement(\"input\", {\n        type: \"checkbox\",\n        checked: hasHeaders,\n        onChange: () => {\n          setHasHeaders(prev => !prev);\n        }\n      }), external_react_default.a.createElement(\"span\", null, l10n.dataHasHeadersCheckbox))), external_react_default.a.createElement(FormatDataRowPreview_FormatDataRowPreview, {\n        hasHeaders: hasHeaders,\n        rows: preview.firstRows\n      })));\n    }, [preview, hasHeaders, l10n]);\n    if (!selectedFile) {\n      return external_react_default.a.createElement(FileSelector_FileSelector, {\n        onSelected: file => setSelectedFile(file)\n      });\n    }\n    return external_react_default.a.createElement(ImporterFrame_ImporterFrame, {\n      fileName: selectedFile.name,\n      nextDisabled: !preview || !!preview.parseError || !!preview.parseWarning,\n      onNext: () => {\n        if (!preview || preview.parseError) {\n          throw new Error('unexpected missing preview info');\n        }\n        onAccept();\n      },\n      onCancel: () => setSelectedFile(null),\n      nextLabel: l10n.nextButton\n    }, reportBlock || external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_FileStep__mainPendingBlock\"\n    }, l10n.previewLoadingStatus));\n  };\n\n  // CONCATENATED MODULE: ./src/components/fields-step/ColumnPreview.tsx\n  // spreadsheet-style column code computation (A, B, ..., Z, AA, AB, ..., etc)\n  function generateColumnCode(value) {\n    // ignore dummy index\n    if (value < 0) {\n      return '';\n    }\n    // first, determine how many base-26 letters there should be\n    // (because the notation is not purely positional)\n    let digitCount = 1;\n    let base = 0;\n    let next = 26;\n    while (next <= value) {\n      digitCount += 1;\n      base = next;\n      next = next * 26 + 26;\n    }\n    // then, apply normal positional digit computation on remainder above base\n    let remainder = value - base;\n    const digits = [];\n    while (digits.length < digitCount) {\n      const lastDigit = remainder % 26;\n      remainder = Math.floor((remainder - lastDigit) / 26); // applying floor just in case\n      // store ASCII code, with A as 0\n      digits.unshift(65 + lastDigit);\n    }\n    return String.fromCharCode.apply(null, digits);\n  }\n  // prepare spreadsheet-like column display information for given raw data preview\n  function generatePreviewColumns(firstRows, hasHeaders) {\n    const columnStubs = [...new Array(firstRows[0].length)];\n    return columnStubs.map((empty, index) => {\n      const values = firstRows.map(row => row[index] || '');\n      const headerValue = hasHeaders ? values.shift() : undefined;\n      return {\n        index,\n        header: headerValue,\n        values\n      };\n    });\n  }\n\n  // EXTERNAL MODULE: external \"react-use-gesture\"\n  var external_react_use_gesture_ = __webpack_require__(3);\n\n  // CONCATENATED MODULE: ./src/components/fields-step/ColumnDragState.tsx\n\n  function useColumnDragState(fields, initialAssignments, onTouched) {\n    // wrap in ref to avoid re-triggering\n    const onTouchedRef = Object(external_react_[\"useRef\"])(onTouched);\n    onTouchedRef.current = onTouched;\n    const [dragState, setDragState] = Object(external_react_[\"useState\"])(null);\n    const [fieldAssignments, setFieldAssignments] = Object(external_react_[\"useState\"])(initialAssignments);\n    // make sure there are no extra fields\n    Object(external_react_[\"useEffect\"])(() => {\n      const removedFieldNames = Object.keys(fieldAssignments).filter(existingFieldName => !fields.some(field => field.name === existingFieldName));\n      if (removedFieldNames.length > 0) {\n        // @todo put everything inside this setter\n        setFieldAssignments(prev => {\n          const copy = Object.assign({}, prev);\n          removedFieldNames.forEach(fieldName => {\n            delete copy[fieldName];\n          });\n          return copy;\n        });\n      }\n    }, [fields, fieldAssignments]);\n    const internalAssignHandler = Object(external_react_[\"useCallback\"])((column, fieldName) => {\n      setFieldAssignments(prevAssignments => {\n        const copy = Object.assign({}, prevAssignments);\n        // ensure dropped column does not show up elsewhere\n        Object.keys(prevAssignments).forEach(name => {\n          if (copy[name] === column.index) {\n            delete copy[name];\n          }\n        });\n        // set new field column\n        if (fieldName !== null) {\n          copy[fieldName] = column.index;\n        }\n        return copy;\n      });\n      // mark for validation display\n      if (fieldName) {\n        onTouchedRef.current(fieldName);\n      }\n    }, []);\n    const bindDrag = Object(external_react_use_gesture_[\"useDrag\"])(_ref11 => {\n      let {\n        first,\n        last,\n        event,\n        xy,\n        args\n      } = _ref11;\n      if (first && event) {\n        // only prevent default inside first event\n        // (touchmove uses passive event handler and would trigger warning)\n        event.preventDefault();\n        const [column, startFieldName] = args;\n        setDragState({\n          pointerStartInfo: {\n            initialXY: xy,\n            initialWidth: event.currentTarget instanceof HTMLElement ? event.currentTarget.offsetWidth : 0\n          },\n          column,\n          dropFieldName: startFieldName !== undefined ? startFieldName : null,\n          updateListeners: {}\n        });\n      } else if (last) {\n        setDragState(null);\n        if (dragState) {\n          internalAssignHandler(dragState.column, dragState.dropFieldName);\n        }\n      }\n      // @todo figure out a cleaner event stream solution\n      if (dragState) {\n        const listeners = dragState.updateListeners;\n        for (const key of Object.keys(listeners)) {\n          listeners[key](xy);\n        }\n      }\n    }, {});\n    // when dragging, set root-level user-select:none to prevent text selection, see Importer.scss\n    // (done via class toggle to avoid interfering with any other dynamic style changes)\n    Object(external_react_[\"useEffect\"])(() => {\n      if (dragState) {\n        document.body.classList.add('CSVImporter_dragging');\n      } else {\n        // remove text selection prevention after a delay (otherwise on iOS it still selects something)\n        const timeoutId = setTimeout(() => {\n          document.body.classList.remove('CSVImporter_dragging');\n        }, 200);\n        return () => {\n          // if another drag state comes along then cancel our delay and just clean up class right away\n          clearTimeout(timeoutId);\n          document.body.classList.remove('CSVImporter_dragging');\n        };\n      }\n    }, [dragState]);\n    const columnSelectHandler = Object(external_react_[\"useCallback\"])(column => {\n      setDragState(prev => {\n        // toggle off if needed\n        if (prev && prev.column === column) {\n          return null;\n        }\n        return {\n          pointerStartInfo: null,\n          column,\n          dropFieldName: null,\n          updateListeners: {}\n        };\n      });\n    }, []);\n    const dragHoverHandler = Object(external_react_[\"useCallback\"])((fieldName, isOn) => {\n      setDragState(prev => {\n        if (!prev) {\n          return prev;\n        }\n        if (isOn) {\n          // set the new drop target\n          return Object.assign(Object.assign({}, prev), {\n            dropFieldName: fieldName\n          });\n        } else if (prev.dropFieldName === fieldName) {\n          // clear drop target if we are still the current one\n          return Object.assign(Object.assign({}, prev), {\n            dropFieldName: null\n          });\n        }\n        // no changes by default\n        return prev;\n      });\n    }, []);\n    const assignHandler = Object(external_react_[\"useCallback\"])(fieldName => {\n      // clear active drag state\n      setDragState(null);\n      if (dragState) {\n        internalAssignHandler(dragState.column, fieldName);\n      }\n    }, [internalAssignHandler, dragState]);\n    const unassignHandler = Object(external_react_[\"useCallback\"])(column => {\n      setFieldAssignments(prev => {\n        const assignedFieldName = Object.keys(prev).find(fieldName => prev[fieldName] === column.index);\n        if (assignedFieldName === undefined) {\n          return prev;\n        }\n        const copy = Object.assign({}, prev);\n        delete copy[assignedFieldName];\n        return copy;\n      });\n    }, []);\n    return {\n      fieldAssignments,\n      dragState,\n      dragEventBinder: bindDrag,\n      dragHoverHandler,\n      columnSelectHandler,\n      assignHandler,\n      unassignHandler\n    };\n  }\n\n  // EXTERNAL MODULE: external \"react-dom\"\n  var external_react_dom_ = __webpack_require__(4);\n\n  // EXTERNAL MODULE: ./src/components/fields-step/ColumnDragCard.scss\n  var ColumnDragCard = __webpack_require__(13);\n\n  // CONCATENATED MODULE: ./src/components/fields-step/ColumnDragCard.tsx\n\n  // @todo sort out \"grabbing\" cursor state (does not work with pointer-events:none)\n  const ColumnDragCard_ColumnDragCard = _ref12 => {\n    let {\n      hasHeaders,\n      column: optionalColumn,\n      rowCount = PREVIEW_ROW_COUNT,\n      hasError,\n      isAssigned,\n      isShadow,\n      isDraggable,\n      isDragged,\n      isDropIndicator\n    } = _ref12;\n    const isDummy = !optionalColumn;\n    const column = Object(external_react_[\"useMemo\"])(() => optionalColumn || {\n      index: -1,\n      code: '',\n      header: hasHeaders ? '' : undefined,\n      values: [...new Array(PREVIEW_ROW_COUNT)].map(() => '')\n    }, [optionalColumn, hasHeaders]);\n    const headerValue = column.header;\n    const dataValues = column.values.slice(0, headerValue === undefined ? rowCount : rowCount - 1);\n    const l10n = useLocale('fieldsStep');\n    return (\n      // not changing variant dynamically because it causes a height jump\n      external_react_default.a.createElement(\"div\", {\n        key: isDummy || isShadow ? 1 : isDropIndicator ? 2 : 0,\n        className: \"CSVImporter_ColumnDragCard\",\n        \"data-dummy\": !!isDummy,\n        \"data-error\": !!hasError,\n        \"data-shadow\": !!isShadow,\n        \"data-draggable\": !!isDraggable,\n        \"data-dragged\": !!isDragged,\n        \"data-drop-indicator\": !!isDropIndicator\n      }, external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_ColumnDragCard__cardHeader\"\n      }, isDummy ? external_react_default.a.createElement(\"var\", {\n        role: \"text\"\n      }, l10n.columnCardDummyHeader) : external_react_default.a.createElement(\"var\", {\n        role: \"text\"\n      }, l10n.getColumnCardHeader(column.code)), isDummy || isAssigned ? '\\u00a0' : external_react_default.a.createElement(\"b\", {\n        \"aria-hidden\": true\n      }, column.code)), headerValue !== undefined ? external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_ColumnDragCard__cardValue\",\n        \"data-header\": true\n      }, headerValue || '\\u00a0') : null, external_react_default.a.createElement(\"div\", {\n        role: \"text\"\n      }, dataValues.map((value, valueIndex) => external_react_default.a.createElement(\"div\", {\n        key: valueIndex,\n        className: \"CSVImporter_ColumnDragCard__cardValue\"\n      }, value || '\\u00a0'))))\n    );\n  };\n\n  // EXTERNAL MODULE: ./src/components/fields-step/ColumnDragObject.scss\n  var ColumnDragObject = __webpack_require__(14);\n\n  // CONCATENATED MODULE: ./src/components/fields-step/ColumnDragObject.tsx\n\n  const ColumnDragObject_ColumnDragObject = _ref13 => {\n    let {\n      dragState\n    } = _ref13;\n    const referenceBoxRef = Object(external_react_[\"useRef\"])(null);\n    // @todo wrap in a no-events overlay to clip against screen edges\n    const dragBoxRef = Object(external_react_[\"useRef\"])(null);\n    const dragObjectPortal = dragState && dragState.pointerStartInfo ? Object(external_react_dom_[\"createPortal\"])(external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragObject\"\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragObject__positioner\",\n      ref: dragBoxRef\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragObject__holder\"\n    }, external_react_default.a.createElement(ColumnDragCard_ColumnDragCard, {\n      column: dragState.column,\n      isDragged: true\n    })))), document.body) : null;\n    // set up initial position\n    const pointerStartInfo = dragState && dragState.pointerStartInfo;\n    Object(external_react_[\"useLayoutEffect\"])(() => {\n      if (!pointerStartInfo || !dragBoxRef.current) {\n        return;\n      }\n      const {\n        initialXY,\n        initialWidth\n      } = pointerStartInfo;\n      dragBoxRef.current.style.left = `${initialXY[0]}px`;\n      dragBoxRef.current.style.top = `${initialXY[1]}px`;\n      dragBoxRef.current.style.width = `${initialWidth}px`;\n      // copy known font style from main content\n      // @todo consider other text style properties?\n      if (referenceBoxRef.current) {\n        const computedStyle = window.getComputedStyle(referenceBoxRef.current);\n        dragBoxRef.current.style.fontFamily = computedStyle.fontFamily;\n        dragBoxRef.current.style.fontSize = computedStyle.fontSize;\n        dragBoxRef.current.style.fontWeight = computedStyle.fontWeight;\n        dragBoxRef.current.style.fontStyle = computedStyle.fontStyle;\n        dragBoxRef.current.style.letterSpacing = computedStyle.letterSpacing;\n      }\n    }, [pointerStartInfo]);\n    // subscribe to live position updates without state changes\n    Object(external_react_[\"useLayoutEffect\"])(() => {\n      if (dragState) {\n        dragState.updateListeners['dragObj'] = xy => {\n          if (!dragBoxRef.current) {\n            return;\n          }\n          dragBoxRef.current.style.left = `${xy[0]}px`;\n          dragBoxRef.current.style.top = `${xy[1]}px`;\n        };\n      }\n    }, [dragState]);\n    return external_react_default.a.createElement(\"div\", {\n      ref: referenceBoxRef\n    }, dragObjectPortal);\n  };\n\n  // EXTERNAL MODULE: ./src/components/fields-step/ColumnDragSourceArea.scss\n  var ColumnDragSourceArea = __webpack_require__(15);\n\n  // CONCATENATED MODULE: ./src/components/fields-step/ColumnDragSourceArea.tsx\n\n  const SOURCES_PAGE_SIZE = 5; // fraction of 10 for easier counting\n  // @todo readable status text if not mouse-drag\n  const SourceBox = _ref14 => {\n    let {\n      column,\n      fieldAssignments,\n      dragState,\n      eventBinder,\n      onSelect,\n      onUnassign\n    } = _ref14;\n    const isDragged = dragState ? column === dragState.column : false;\n    const isAssigned = Object(external_react_[\"useMemo\"])(() => Object.keys(fieldAssignments).some(fieldName => fieldAssignments[fieldName] === column.index), [fieldAssignments, column]);\n    const eventHandlers = Object(external_react_[\"useMemo\"])(() => eventBinder(column), [eventBinder, column]);\n    const l10n = useLocale('fieldsStep');\n    return external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__box\"\n    }, external_react_default.a.createElement(\"div\", Object.assign({}, isAssigned ? {} : eventHandlers), external_react_default.a.createElement(ColumnDragCard_ColumnDragCard, {\n      column: column,\n      isAssigned: isAssigned,\n      isShadow: isDragged || isAssigned,\n      isDraggable: !dragState && !isDragged && !isAssigned\n    })), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__boxAction\"\n    }, isAssigned ? external_react_default.a.createElement(IconButton_IconButton, {\n      key: \"clear\" // key-prop helps clear focus on click\n      ,\n      label: l10n.clearAssignmentTooltip,\n      small: true,\n      type: \"replay\",\n      onClick: () => {\n        onUnassign(column);\n      }\n    }) : external_react_default.a.createElement(IconButton_IconButton, {\n      key: \"dragSelect\" // key-prop helps clear focus on click\n      ,\n      focusOnly: true,\n      label: dragState && dragState.column === column ? l10n.unselectColumnTooltip : l10n.selectColumnTooltip,\n      small: true,\n      type: \"back\",\n      onClick: () => {\n        onSelect(column);\n      }\n    })));\n  };\n  // @todo current page indicator (dots)\n  const ColumnDragSourceArea_ColumnDragSourceArea = _ref15 => {\n    let {\n      columns,\n      fieldAssignments,\n      dragState,\n      eventBinder,\n      onSelect,\n      onUnassign\n    } = _ref15;\n    const [page, setPage] = Object(external_react_[\"useState\"])(0);\n    const [pageChanged, setPageChanged] = Object(external_react_[\"useState\"])(false);\n    const pageCount = Math.ceil(columns.length / SOURCES_PAGE_SIZE);\n    const start = page * SOURCES_PAGE_SIZE;\n    const pageContents = columns.slice(start, start + SOURCES_PAGE_SIZE).map((column, columnIndex) => external_react_default.a.createElement(SourceBox, {\n      key: columnIndex,\n      column: column,\n      fieldAssignments: fieldAssignments,\n      dragState: dragState,\n      eventBinder: eventBinder,\n      onSelect: onSelect,\n      onUnassign: onUnassign\n    }));\n    while (pageContents.length < SOURCES_PAGE_SIZE) {\n      pageContents.push(external_react_default.a.createElement(\"div\", {\n        key: pageContents.length,\n        className: \"CSVImporter_ColumnDragSourceArea__pageFiller\"\n      }));\n    }\n    const l10n = useLocale('fieldsStep');\n    return external_react_default.a.createElement(\"section\", {\n      className: \"CSVImporter_ColumnDragSourceArea\",\n      \"aria-label\": l10n.dragSourceAreaCaption\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__control\"\n    }, external_react_default.a.createElement(IconButton_IconButton, {\n      label: l10n.previousColumnsTooltip,\n      type: \"back\",\n      disabled: page === 0,\n      onClick: () => {\n        setPage(prev => Math.max(0, prev - 1));\n        setPageChanged(true);\n      }\n    })), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__page\"\n    }, dragState && !dragState.pointerStartInfo ? external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\",\n      role: \"status\"\n    }, l10n.getDragSourceActiveStatus(dragState.column.code)) :\n    // show page number if needed (and treat as status role if it has changed)\n    // @todo changing role to status does not seem to work\n    pageCount > 1 && external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\",\n      role: pageChanged ? 'status' : 'text'\n    }, l10n.getDragSourcePageIndicator(page + 1, pageCount)), pageContents), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__control\"\n    }, external_react_default.a.createElement(IconButton_IconButton, {\n      label: l10n.nextColumnsTooltip,\n      type: \"forward\",\n      disabled: page === pageCount - 1,\n      onClick: () => {\n        setPage(prev => Math.min(pageCount - 1, prev + 1));\n      }\n    })));\n  };\n\n  // EXTERNAL MODULE: ./src/components/fields-step/ColumnDragTargetArea.scss\n  var ColumnDragTargetArea = __webpack_require__(16);\n\n  // CONCATENATED MODULE: ./src/components/fields-step/ColumnDragTargetArea.tsx\n\n  const TargetBox = _ref16 => {\n    let {\n      hasHeaders,\n      field,\n      touched,\n      assignedColumn,\n      dragState,\n      eventBinder,\n      onHover,\n      onAssign,\n      onUnassign\n    } = _ref16;\n    // wrap in ref to avoid re-triggering effect\n    const onHoverRef = Object(external_react_[\"useRef\"])(onHover);\n    onHoverRef.current = onHover;\n    // respond to hover events when there is active mouse drag happening\n    // (not keyboard-emulated one)\n    const containerRef = Object(external_react_[\"useRef\"])(null);\n    const isHoveredRef = Object(external_react_[\"useRef\"])(false); // simple tracking of current hover state to avoid spamming onHover (not for display)\n    Object(external_react_[\"useEffect\"])(() => {\n      const container = containerRef.current;\n      if (!dragState || !dragState.pointerStartInfo || !container) {\n        return;\n      }\n      // measure the current scroll-independent position\n      const rect = container.getBoundingClientRect();\n      const minX = rect.x;\n      const maxX = rect.x + rect.width;\n      const minY = rect.y;\n      const maxY = rect.y + rect.height;\n      // listen for pointer movement (mouse or touch) and detect hover\n      const listeners = dragState.updateListeners;\n      const listenerName = `field:${field.name}`;\n      listeners[listenerName] = xy => {\n        const isInBounds = xy[0] >= minX && xy[0] < maxX && xy[1] >= minY && xy[1] < maxY;\n        if (isInBounds !== isHoveredRef.current) {\n          // cannot use local var for isHovered state because the effect re-triggers after this\n          isHoveredRef.current = isInBounds;\n          onHoverRef.current(field.name, isInBounds);\n        }\n      };\n      // cleanup\n      return () => {\n        delete listeners[listenerName];\n      };\n    }, [dragState, field.name]);\n    // if this field is the current highlighted drop target,\n    // get the originating column data for display\n    const sourceColumn = dragState && dragState.dropFieldName === field.name ? dragState.column : null;\n    // see if currently assigned column is being dragged again\n    const isReDragged = dragState ? dragState.column === assignedColumn : false;\n    // drag start handlers for columns that can be re-dragged (i.e. are assigned)\n    const dragStartHandlers = Object(external_react_[\"useMemo\"])(() => assignedColumn && !isReDragged ? eventBinder(assignedColumn, field.name) : {}, [eventBinder, assignedColumn, isReDragged, field.name]);\n    const valueContents = Object(external_react_[\"useMemo\"])(() => {\n      if (sourceColumn) {\n        return external_react_default.a.createElement(ColumnDragCard_ColumnDragCard, {\n          rowCount: 3,\n          column: sourceColumn,\n          isDropIndicator: true\n        });\n      }\n      if (assignedColumn) {\n        return external_react_default.a.createElement(ColumnDragCard_ColumnDragCard, {\n          rowCount: 3,\n          column: assignedColumn,\n          isShadow: isReDragged,\n          isDraggable: !isReDragged\n        });\n      }\n      const hasError = touched && !field.isOptional;\n      return external_react_default.a.createElement(ColumnDragCard_ColumnDragCard, {\n        rowCount: 3,\n        hasHeaders: hasHeaders,\n        hasError: hasError\n      });\n    }, [hasHeaders, field, touched, assignedColumn, sourceColumn, isReDragged]);\n    const l10n = useLocale('fieldsStep');\n    // @todo mouse cursor changes to reflect draggable state\n    return external_react_default.a.createElement(\"section\", {\n      className: \"CSVImporter_ColumnDragTargetArea__box\",\n      \"aria-label\": field.isOptional ? l10n.getDragTargetOptionalCaption(field.label) : l10n.getDragTargetRequiredCaption(field.label),\n      ref: containerRef\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragTargetArea__boxLabel\",\n      \"aria-hidden\": true\n    }, field.label, field.isOptional ? null : external_react_default.a.createElement(\"b\", null, \"*\")), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragTargetArea__boxValue\"\n    }, !sourceColumn && !assignedColumn && external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragTargetArea__boxPlaceholderHelp\",\n      \"aria-hidden\": true\n    }, l10n.dragTargetPlaceholder), external_react_default.a.createElement(\"div\", Object.assign({}, dragStartHandlers), valueContents), dragState && !dragState.pointerStartInfo ? external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\"\n    }, external_react_default.a.createElement(IconButton_IconButton, {\n      label: l10n.getDragTargetAssignTooltip(dragState.column.code),\n      small: true,\n      type: \"forward\",\n      onClick: () => onAssign(field.name)\n    })) : !sourceColumn && assignedColumn && external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\"\n    }, external_react_default.a.createElement(IconButton_IconButton, {\n      label: l10n.dragTargetClearTooltip,\n      small: true,\n      type: \"close\",\n      onClick: () => onUnassign(assignedColumn)\n    }))));\n  };\n  const ColumnDragTargetArea_ColumnDragTargetArea = _ref17 => {\n    let {\n      hasHeaders,\n      fields,\n      columns,\n      fieldTouched,\n      fieldAssignments,\n      dragState,\n      eventBinder,\n      onHover,\n      onAssign,\n      onUnassign\n    } = _ref17;\n    const l10n = useLocale('fieldsStep');\n    return external_react_default.a.createElement(\"section\", {\n      className: \"CSVImporter_ColumnDragTargetArea\",\n      \"aria-label\": l10n.dragTargetAreaCaption\n    }, fields.map(field => {\n      const assignedColumnIndex = fieldAssignments[field.name];\n      return external_react_default.a.createElement(TargetBox, {\n        key: field.name,\n        field: field,\n        touched: fieldTouched[field.name],\n        hasHeaders: hasHeaders,\n        assignedColumn: assignedColumnIndex !== undefined ? columns[assignedColumnIndex] : null,\n        dragState: dragState,\n        eventBinder: eventBinder,\n        onHover: onHover,\n        onAssign: onAssign,\n        onUnassign: onUnassign\n      });\n    }));\n  };\n\n  // CONCATENATED MODULE: ./src/components/fields-step/FieldsStep.tsx\n\n  const FieldsStep = _ref18 => {\n    let {\n      fileState,\n      fields,\n      prevState,\n      onChange,\n      onAccept,\n      onCancel\n    } = _ref18;\n    const onChangeRef = Object(external_react_[\"useRef\"])(onChange);\n    onChangeRef.current = onChange;\n    const columns = Object(external_react_[\"useMemo\"])(() => generatePreviewColumns(fileState.firstRows, fileState.hasHeaders).map(item => Object.assign(Object.assign({}, item), {\n      code: generateColumnCode(item.index)\n    })), [fileState]);\n    const initialAssignments = Object(external_react_[\"useMemo\"])(() => {\n      // prep insensitive/fuzzy match stems for known columns\n      // (this is ignored if there is already previous state to seed from)\n      const columnStems = columns.map(column => {\n        const trimmed = column.header && column.header.trim();\n        if (!trimmed) {\n          return undefined;\n        }\n        return trimmed.toLowerCase();\n      });\n      // pre-assign corresponding fields\n      const result = {};\n      const assignedColumnIndexes = [];\n      fields.forEach(field => {\n        // find by field stem\n        const fieldLabelStem = field.label.trim().toLowerCase(); // @todo consider normalizing other whitespace/non-letters\n        const matchingColumnIndex = columnStems.findIndex((columnStem, columnIndex) => {\n          // no headers or no meaningful stem value\n          if (columnStem === undefined) {\n            return false;\n          }\n          // always check against assigning twice\n          if (assignedColumnIndexes[columnIndex]) {\n            return false;\n          }\n          return columnStem === fieldLabelStem;\n        });\n        // assign if found\n        if (matchingColumnIndex !== -1) {\n          assignedColumnIndexes[matchingColumnIndex] = true;\n          result[field.name] = matchingColumnIndex;\n        }\n      });\n      return result;\n    }, [fields, columns]);\n    // track which fields need to show validation warning\n    const [fieldTouched, setFieldTouched] = Object(external_react_[\"useState\"])({});\n    const [validationError, setValidationError] = Object(external_react_[\"useState\"])(null);\n    const {\n      fieldAssignments,\n      dragState,\n      dragEventBinder,\n      dragHoverHandler,\n      columnSelectHandler,\n      assignHandler,\n      unassignHandler\n    } = useColumnDragState(fields, prevState ? prevState.fieldAssignments : initialAssignments, fieldName => {\n      setFieldTouched(prev => {\n        if (prev[fieldName]) {\n          return prev;\n        }\n        const copy = Object.assign({}, prev);\n        copy[fieldName] = true;\n        return copy;\n      });\n    });\n    // notify of current state\n    Object(external_react_[\"useEffect\"])(() => {\n      onChangeRef.current({\n        fieldAssignments: Object.assign({}, fieldAssignments)\n      });\n    }, [fieldAssignments]);\n    const l10n = useLocale('fieldsStep');\n    return external_react_default.a.createElement(ImporterFrame_ImporterFrame, {\n      fileName: fileState.file.name,\n      subtitle: l10n.stepSubtitle,\n      error: validationError,\n      onCancel: onCancel,\n      onNext: () => {\n        // mark all fields as touched\n        const fullTouchedMap = {};\n        fields.some(field => {\n          fullTouchedMap[field.name] = true;\n        });\n        setFieldTouched(fullTouchedMap);\n        // submit if validation succeeds\n        const hasUnassignedRequired = fields.some(field => !field.isOptional && fieldAssignments[field.name] === undefined);\n        if (!hasUnassignedRequired) {\n          onAccept();\n        } else {\n          setValidationError(l10n.requiredFieldsError);\n        }\n      },\n      nextLabel: l10n.nextButton\n    }, external_react_default.a.createElement(ColumnDragSourceArea_ColumnDragSourceArea, {\n      columns: columns,\n      fieldAssignments: fieldAssignments,\n      dragState: dragState,\n      eventBinder: dragEventBinder,\n      onSelect: columnSelectHandler,\n      onUnassign: unassignHandler\n    }), external_react_default.a.createElement(ColumnDragTargetArea_ColumnDragTargetArea, {\n      hasHeaders: fileState.hasHeaders,\n      fields: fields,\n      columns: columns,\n      fieldTouched: fieldTouched,\n      fieldAssignments: fieldAssignments,\n      dragState: dragState,\n      eventBinder: dragEventBinder,\n      onHover: dragHoverHandler,\n      onAssign: assignHandler,\n      onUnassign: unassignHandler\n    }), external_react_default.a.createElement(ColumnDragObject_ColumnDragObject, {\n      dragState: dragState\n    }));\n  };\n\n  // EXTERNAL MODULE: ./src/components/ProgressDisplay.scss\n  var ProgressDisplay = __webpack_require__(17);\n\n  // CONCATENATED MODULE: ./src/components/ProgressDisplay.tsx\n\n  // compute actual UTF-8 bytes used by a string\n  // (inspired by https://stackoverflow.com/questions/10576905/how-to-convert-javascript-unicode-notation-code-to-utf-8)\n  function countUTF8Bytes(item) {\n    // re-encode into UTF-8\n    const escaped = encodeURIComponent(item);\n    // convert byte escape sequences into single characters\n    const normalized = escaped.replace(/%\\d\\d/g, '_');\n    return normalized.length;\n  }\n  function ProgressDisplay_ProgressDisplay(_ref19) {\n    let {\n      fileState,\n      fieldsState,\n      externalPreview,\n      processChunk,\n      onStart,\n      onComplete,\n      onRestart,\n      onClose\n    } = _ref19;\n    const [progressCount, setProgressCount] = Object(external_react_[\"useState\"])(0);\n    const [isComplete, setIsComplete] = Object(external_react_[\"useState\"])(false);\n    const [error, setError] = Object(external_react_[\"useState\"])(null);\n    const [isDismissed, setIsDismissed] = Object(external_react_[\"useState\"])(false); // prevents double-clicking finish\n    // info object exposed to the progress callbacks\n    const importInfo = Object(external_react_[\"useMemo\"])(() => {\n      const fieldList = Object.keys(fieldsState.fieldAssignments);\n      const columnSparseList = [];\n      fieldList.forEach(field => {\n        const col = fieldsState.fieldAssignments[field];\n        if (col !== undefined) {\n          columnSparseList[col] = field;\n        }\n      });\n      return {\n        file: fileState.file,\n        preview: externalPreview,\n        fields: fieldList,\n        columnFields: [...columnSparseList]\n      };\n    }, [fileState, fieldsState, externalPreview]);\n    // estimate number of rows\n    const estimatedRowCount = Object(external_react_[\"useMemo\"])(() => {\n      // sum up sizes of all the parsed preview rows and get estimated average\n      const totalPreviewRowBytes = fileState.firstRows.reduce((prevCount, row) => {\n        const rowBytes = row.reduce((prev, item) => {\n          return prev + countUTF8Bytes(item) + 1; // add a byte for separator or newline\n        }, 0);\n        return prevCount + rowBytes;\n      }, 0);\n      const averagePreviewRowSize = totalPreviewRowBytes / fileState.firstRows.length;\n      // divide file size by estimated row size (or fall back to a sensible amount)\n      return averagePreviewRowSize > 1 ? fileState.file.size / averagePreviewRowSize : 100;\n    }, [fileState]);\n    // notify on start of processing\n    // (separate effect in case of errors)\n    const onStartRef = Object(external_react_[\"useRef\"])(onStart); // wrap in ref to avoid re-triggering (only first instance is needed)\n    Object(external_react_[\"useEffect\"])(() => {\n      if (onStartRef.current) {\n        onStartRef.current(importInfo);\n      }\n    }, [importInfo]);\n    // notify on end of processing\n    // (separate effect in case of errors)\n    const onCompleteRef = Object(external_react_[\"useRef\"])(onComplete); // wrap in ref to avoid re-triggering\n    onCompleteRef.current = onComplete;\n    Object(external_react_[\"useEffect\"])(() => {\n      if (isComplete && onCompleteRef.current) {\n        onCompleteRef.current(importInfo);\n      }\n    }, [importInfo, isComplete]);\n    // ensure status gets focus when complete, in case status role is not read out\n    const statusRef = Object(external_react_[\"useRef\"])(null);\n    Object(external_react_[\"useEffect\"])(() => {\n      if ((isComplete || error) && statusRef.current) {\n        statusRef.current.focus();\n      }\n    }, [isComplete, error]);\n    // perform main async parse\n    const processChunkRef = Object(external_react_[\"useRef\"])(processChunk); // wrap in ref to avoid re-triggering\n    const asyncLockRef = Object(external_react_[\"useRef\"])(0);\n    Object(external_react_[\"useEffect\"])(() => {\n      const oplock = asyncLockRef.current;\n      processFile(Object.assign(Object.assign({}, fileState), {\n        fieldAssignments: fieldsState.fieldAssignments\n      }), deltaCount => {\n        // ignore if stale\n        if (oplock !== asyncLockRef.current) {\n          return; // @todo signal abort\n        }\n\n        setProgressCount(prev => prev + deltaCount);\n      }, processChunkRef.current).then(() => {\n        // ignore if stale\n        if (oplock !== asyncLockRef.current) {\n          return;\n        }\n        setIsComplete(true);\n      }, error => {\n        // ignore if stale\n        if (oplock !== asyncLockRef.current) {\n          return;\n        }\n        setError(error);\n      });\n      return () => {\n        // invalidate current oplock on change or unmount\n        asyncLockRef.current += 1;\n      };\n    }, [fileState, fieldsState]);\n    // simulate asymptotic progress percentage\n    const progressPercentage = Object(external_react_[\"useMemo\"])(() => {\n      if (isComplete) {\n        return 100;\n      }\n      // inputs hand-picked so that correctly estimated total is about 75% of the bar\n      const progressPower = 2.5 * (progressCount / estimatedRowCount);\n      const progressLeft = Math.pow(0.5, progressPower);\n      // convert to .1 percent precision for smoother bar display\n      return Math.floor(1000 - 1000 * progressLeft) / 10;\n    }, [estimatedRowCount, progressCount, isComplete]);\n    const l10n = useLocale('progressStep');\n    return external_react_default.a.createElement(ImporterFrame_ImporterFrame, {\n      fileName: fileState.file.name,\n      subtitle: l10n.stepSubtitle,\n      error: error && (error.message || String(error)),\n      secondaryDisabled: !isComplete || isDismissed,\n      secondaryLabel: onRestart && onClose ? l10n.uploadMoreButton : undefined,\n      onSecondary: onRestart && onClose ? onRestart : undefined,\n      nextDisabled: !isComplete || isDismissed,\n      nextLabel: !!(onClose || onRestart) && (onRestart ? l10n.uploadMoreButton : l10n.finishButton),\n      onNext: () => {\n        if (onClose) {\n          setIsDismissed(true);\n          onClose(importInfo);\n        } else if (onRestart) {\n          onRestart();\n        }\n      }\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ProgressDisplay\"\n    }, isComplete || error ? external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ProgressDisplay__status\",\n      role: \"status\",\n      tabIndex: -1,\n      ref: statusRef\n    }, error ? l10n.statusError : l10n.statusComplete) : external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ProgressDisplay__status -pending\",\n      role: \"status\"\n    }, l10n.statusPending), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ProgressDisplay__count\",\n      role: \"text\"\n    }, external_react_default.a.createElement(\"var\", null, l10n.processedRowsLabel), \" \", progressCount), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ProgressDisplay__progressBar\"\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ProgressDisplay__progressBarIndicator\",\n      style: {\n        width: `${progressPercentage}%`\n      }\n    }))));\n  }\n\n  // EXTERNAL MODULE: ./src/components/Importer.scss\n  var Importer = __webpack_require__(18);\n\n  // CONCATENATED MODULE: ./src/components/Importer.tsx\n  var __rest = undefined && undefined.__rest || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n  };\n  const FieldDefinitionContext = external_react_default.a.createContext(null);\n  let fieldIdCount = 0;\n  // defines a field to be filled from file column during import\n  const ImporterField = _ref20 => {\n    let {\n      name,\n      label,\n      optional\n    } = _ref20;\n    // @todo this is not SSR-compatible\n    const fieldId = Object(external_react_[\"useMemo\"])(() => fieldIdCount += 1, []);\n    const fieldSetter = Object(external_react_[\"useContext\"])(FieldDefinitionContext);\n    // update central list as needed\n    Object(external_react_[\"useEffect\"])(() => {\n      if (!fieldSetter) {\n        console.error('importer field must be a child of importer'); // @todo\n        return;\n      }\n      fieldSetter(prev => {\n        const newField = {\n          id: fieldId,\n          name,\n          label,\n          isOptional: !!optional\n        };\n        const copy = [...prev];\n        const existingIndex = copy.findIndex(item => item.name === name);\n        // preserve existing array position if possible\n        // @todo keep both copies in a map to deal with dynamic fields better\n        if (existingIndex === -1) {\n          copy.push(newField);\n        } else {\n          copy[existingIndex] = newField;\n        }\n        return copy;\n      });\n    }, [fieldId, fieldSetter, name, label, optional]);\n    // on component unmount, remove this field from list by ID\n    Object(external_react_[\"useEffect\"])(() => {\n      if (!fieldSetter) {\n        console.error('importer field must be a child of importer'); // @todo\n        return;\n      }\n      return () => {\n        fieldSetter(prev => {\n          return prev.filter(field => field.id !== fieldId);\n        });\n      };\n    }, [fieldId, fieldSetter]);\n    return null;\n  };\n  function Importer_Importer(_a) {\n    var {\n        assumeNoHeaders,\n        restartable,\n        processChunk,\n        onStart,\n        onComplete,\n        onClose,\n        children: content,\n        locale\n      } = _a,\n      customPapaParseConfig = __rest(_a, [\"assumeNoHeaders\", \"restartable\", \"processChunk\", \"onStart\", \"onComplete\", \"onClose\", \"children\", \"locale\"]);\n    // helper to combine our displayed content and the user code that provides field definitions\n    const [fields, setFields] = Object(external_react_[\"useState\"])([]);\n    const [fileState, setFileState] = Object(external_react_[\"useState\"])(null);\n    const [fileAccepted, setFileAccepted] = Object(external_react_[\"useState\"])(false);\n    const [fieldsState, setFieldsState] = Object(external_react_[\"useState\"])(null);\n    const [fieldsAccepted, setFieldsAccepted] = Object(external_react_[\"useState\"])(false);\n    // reset field assignments when file changes\n    const activeFile = fileState && fileState.file;\n    Object(external_react_[\"useEffect\"])(() => {\n      if (activeFile) {\n        setFieldsState(null);\n      }\n    }, [activeFile]);\n    const externalPreview = Object(external_react_[\"useMemo\"])(() => {\n      // generate stable externally-visible data objects\n      const externalColumns = fileState && generatePreviewColumns(fileState.firstRows, fileState.hasHeaders);\n      return fileState && externalColumns && {\n        rawData: fileState.firstChunk,\n        columns: externalColumns,\n        skipHeaders: !fileState.hasHeaders,\n        parseWarning: fileState.parseWarning\n      };\n    }, [fileState]);\n    // render provided child content that defines the fields\n    const contentNodes = Object(external_react_[\"useMemo\"])(() => {\n      return typeof content === 'function' ? content({\n        file: fileState && fileState.file,\n        preview: externalPreview\n      }) : content;\n    }, [fileState, externalPreview, content]);\n    const contentWrap = external_react_default.a.createElement(FieldDefinitionContext.Provider, {\n      value: setFields\n    }, contentNodes);\n    // fall back to enUS if no default locale provided\n    locale = locale !== null && locale !== void 0 ? locale : enUS;\n    if (!fileAccepted || fileState === null || externalPreview === null) {\n      return external_react_default.a.createElement(LocaleContext.Provider, {\n        value: locale\n      }, external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_Importer\"\n      }, external_react_default.a.createElement(FileStep_FileStep, {\n        customConfig: customPapaParseConfig,\n        assumeNoHeaders: assumeNoHeaders,\n        prevState: fileState,\n        onChange: parsedPreview => {\n          setFileState(parsedPreview);\n        },\n        onAccept: () => {\n          setFileAccepted(true);\n        }\n      }), contentWrap));\n    }\n    if (!fieldsAccepted || fieldsState === null) {\n      return external_react_default.a.createElement(LocaleContext.Provider, {\n        value: locale\n      }, external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_Importer\"\n      }, external_react_default.a.createElement(FieldsStep, {\n        fileState: fileState,\n        fields: fields,\n        prevState: fieldsState,\n        onChange: state => {\n          setFieldsState(state);\n        },\n        onAccept: () => {\n          setFieldsAccepted(true);\n        },\n        onCancel: () => {\n          // keep existing preview data and assignments\n          setFileAccepted(false);\n        }\n      }), contentWrap));\n    }\n    return external_react_default.a.createElement(LocaleContext.Provider, {\n      value: locale\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_Importer\"\n    }, external_react_default.a.createElement(ProgressDisplay_ProgressDisplay, {\n      fileState: fileState,\n      fieldsState: fieldsState,\n      externalPreview: externalPreview,\n      processChunk: processChunk,\n      onStart: onStart,\n      onRestart: restartable ? () => {\n        // reset all state\n        setFileState(null);\n        setFileAccepted(false);\n        setFieldsState(null);\n        setFieldsAccepted(false);\n      } : undefined,\n      onComplete: onComplete,\n      onClose: onClose\n    }), contentWrap));\n  }\n\n  // CONCATENATED MODULE: ./src/index.ts\n\n  /***/\n}\n/******/]);","map":{"version":3,"mappings":";;EAAA;EACA;EAAA;EACA;EACA;EACA;EAAA;IACA;IACA;IACA;MACA;MACA;IAAA;IACA;IACA;IAAA;MACA;MACA;MACA;MACA;IAAA;IACA;IACA;IACA;IAAAA;IACA;IACA;IACA;IAAAC;IACA;IACA;IACA;IAAA;IACA;EAAA;EACA;EACA;EACA;EACA;EAAAC;EACA;EACA;EACA;EAAAA;EACA;EACA;EACA;EAAAA;IACA;MACA;QAAAC;QAAAC;MAAA;MACA;IAAA;IACA;EAAA;EACA;EACA;EACA;EAAAF;IACA;MACA;QAAAG;MAAA;MACA;IAAA;IACA;IAAAC;MAAAD;IAAA;IACA;EAAA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAAAH;IACA;IACA;IAAA;IACA;IAAA;IACA;IAAA;IACA;IAAAA;IACA;IAAAI;MAAAH;MAAAE;IAAA;IACA;IAAA;MAAA;IAAA;IACA;IAAA;IACA;EAAA;EACA;EACA;EACA;EAAAH;IACA,mDACA;MAAA;IAAA,IACA;MAAA;IAAA;IACA;IAAAA;IACA;IAAA;IACA;EAAA;EACA;EACA;EACA;EAAAA;IAAA;EAAA;EACA;EACA;EACA;EAAAA;EACA;EACA;EACA;EACA;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EClFA;;;;;ECAA;;;;;ECAA;;;;;ECAA;;;;;ECAA;;;;;ECAA;;;;;ECAA;;;;;ECAA;;;;;ECAA;;;;;ECAA;;;;;ECAA;;;;;ECAA;;;;;ECAA;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECAA;IACA;MAAA;QAAAK;MAAA;IAAA;IACA;MACA;QAAA;UAAAC;QAAA;UAAAC;QAAA;MAAA;MACA;QAAA;UAAAD;QAAA;UAAAC;QAAA;MAAA;MACA;QAAAC;MAAA;MACAF;IACA;EACA;EAEA;EACA;EACA;EACA;IACA;MACA;IACA;IACA;IACA;MACA;IACA;IACA;EACA;EACA;EACA;EACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;MACA;QACA;QACA;QACA;QACA;QACA;UACA;UACA;YACA;YACA;cAAAG;cAAAN;YAAA;YACA;YACA;cACA;YACA;YACA;YACA;cACA;YACA;YACA;YACA;cACA;cACA;gBACAO;cACA;cACAC;cACA;YACA;YACA;YACA;cAAAC;YAAA;YACAF;UACA;QACA,UACA;UACA;UACAG;QACA;MACA;IACA;IACA;MACA;MACAC;MACAC;QACA;MACA;MACAC;QACA;UACA;YACA;cACA;YACA;YACAN;YACA;YACAO;cACA;gBACAC;cACA,OACA;gBACA;gBACA;cACA;YACA;YACA;UACA;YACA;cACA;YACA;YACAP;YACA;UACA;YACA;cACA;YACA;YACAO;YACA;QAAA;QAEA;MACA;MACA;MACAC;QACA;QACAC;QACAV;QACAC;QACAO;MACA;MACAG;QACA;UACAC;YACAC;UACA;QACA;QACA;MACA;MACAC;QACA;UACAD;UACAD;UACAC;QACA;QACA;MACA;IACA;IACA;IACA;EACA;EACA;IACA;IACA;MACA;MACA;MACA;MACA;QACA;QACA;UACA;YACAE;YACAC;UACA;QACA;QACA;QACA;QACA;QACA;UACAC;QACA;QACAtB;UACAqB;UACAD;UACAG;UACAC;UACAC;UACAC;QACA;MACA;MACA;MACA;MACA;MACA;MACAC;QAAAC;QAAAC;QAAAC;UACA9B;YACAoB;YACAC;UACA;QACA;QAAAU;UACAP;QACA;QAAAQ;UAAA;YAAAC;YAAAC;UAAA;UACAD;YACA;YACAX;UACA;UACA;YACAa;UACA;UACA;UACA;UACA;YACAC;YACAC;YACAC;UACA;QACA;QAAAC;MAAA;IACA;MACA;QACAnB;QACAC;MACA;IACA;EACA;EACA;IACA;MAAAA;MAAAmB;MAAAC;MAAAC;IAAA;IACA;IACA;IACA;MACA;MACA;MACA;MACA;MACA;MACA;MACAf;QAAAC;QAAAE;UACA5B;QACA;QAAA8B;UAAA;YAAAC;UAAA;UACA;UACAG;UACAC;UACA;UACA;YACA;YACA;YACAM;cACA;cACA;gBACAC;cACA;YACA;YACA;UACA;UACA;UACA;YACAC;UACA;UACA;UACA;YACAC;UACA;UACAC;UACA;UACAC;UACA;UACA;UACA;YACA;YACA;YACAC;UACA;UACA;UACAC;YACAd;YACAC;UACA;YACA;YACAD;YACAC;UACA;QACA;QAAAE;UACAvC;QACA;MAAA;IACA;EACA;;;;;;;ECnQA;IAAA;MAAAmD;MAAAC;MAAAC;IAAA;IACA;MAAAC;MAAAH;MAAAC;IAAA;EACA;;;;;;;ECFA;IAAA;MAAAG;MAAAC;MAAAC;MAAAC;MAAAP;MAAAC;IAAA;IACA;MAAAE;MAAA;MAAAH;MAAAC;MAAA;MAAA;IAAA,GACAO;MAAA;IAAA;EACA;;;;;;ECLA;EACA;IACAC;MACAC;IACA;IACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;IACA;IACAC;MACAC;MACAC;MACAP;MACAQ;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;IACA;IACAC;MACAlB;MACAmB;MACAC;MACAC;MACAC;MACAC;MACAC;IACA;EACA;EACA;IACAtC;MACAC;IACA;IACAC;MACAC;MACAC;MACAI;MACAH;MACAC;MACAC;MACAE;MACAC;MACAC;MACAC;IACA;IACAC;MACAC;MACAC;MACAP;MACAQ;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;IACA;IACAC;MACAlB;MACAmB;MACAC;MACAC;MACAC;MACAC;MACAC;IACA;EACA;;;;EC3FA;EACA;IACA;IACA;EACA;;;;ECFA;IAAA;MAAAC;MAAAC;MAAAC;MAAAC;MAAAC;MAAAC;MAAA1E;MAAA2E;MAAAC;MAAAC;MAAAtD;IAAA;IACA;IACA;IACAtD;MACA;QACA6G;MACA,OACA;QACAC;MACA;IACA;IACA;IACA;MAAAvD;IAAA,GACAK;MAAAL;IAAA,GACAK;MAAAH;MAAAD;MAAAJ;MAAAC;IAAA,IACAO;MAAAL;MAAAwD;MAAAC;IAAA,cACAX,2FACAzC;MAAAL;IAAA,GACAK,uDACAA;MAAAL;MAAAwD;MAAAC;IAAA,uBACA1D,UACAM;MAAAL;IAAA,GACAK;MAAAL;IAAA,IACAxB;MAAAwB;MAAA0D;IAAA,kBACAV;MAAAhD;IAAA,GACAK;MAAAR;MAAAC;IAAA,4BACAoD;MAAAlD;IAAA,GACAK;MAAAR;MAAAC;IAAA;EACA;;;;;;;;;;EC7BA;IAAA;MAAA6D;IAAA;IACA;IACAC;IACA;MACA;MACA;QACA;MACA;MACA;MACAA;IACA;IACA;MAAAC;MAAAC;MAAAC;IAAA;MACAC;IACA;IACA;IACA;MAAAhE;MAAA;IAAA,oBACAK,qFACA0D;EACA;;;;;;;EClBA;IAAA;MAAAE;MAAAlE;IAAA;IACA;IACA;MAAAC;IAAA,GACAK,gEACAA;MAAAP;IAAA;EACA;;;;;;;ECLA;EACA;IAAA;MAAApB;MAAAwF;MAAAD;IAAA;IACA;IACA;IACA;IACA;MAAAjE;IAAA,GACAK;MAAAL;IAAA,GACAK;MAAAL;IAAA,GACAmE,YACAC,gFACAF;MAAAD;IAAA;EACA;;;;;;;ECbA;IAAA;MAAA/E;MAAAmF;IAAA;IACA;IACA;IACA;MAAArE;IAAA,GACAK;MAAAL;IAAA,GACAsE,mEACAjE;MAAAkE;IAAA,aACAlE;MAAAkE;IAAA;MAAAA;IAAA;EACA;;;;;;;ECDA;IAAA;MAAAC;MAAAC;MAAAC;MAAAC;MAAAC;IAAA;IACA;IACA;IACA;MAAA9G;IAAA;IACA;IACA;IACA;IACA;IACA+G;IACA;IACAC;IACA;IACAC;IACA;IACAtI;MACAsI,qDACAtI;QAAA0C;QAAAD;MAAA;IACA;IACA;IACA;IACAzC;MACA;MACA;QACAuI;QACA;MACA;MACA;MACA;QACA;MACA;MACA;MACA;MACA;MACA;MACAC;QACA;QACA;UACA;QACA;QACA;QACAD;QACAE;QACA;QACAC,mCACA,QACA;MACA;MACA;QACA;QACAC;MACA;IACA;IACA;IACA;IACA;IACA;MACA;QACA;MACA;MACA;QACA;UAAApF;QAAA,GACAK;UAAA4D;QAAA;MACA;MACA;QAAAjE;MAAA,GACAK;QAAAL;MAAA,iCACAK;QAAA3B;QAAAwF;QAAAD;MAAA,IACA1F,8GACA8B;QAAAL;MAAA,GACAqF,2BACA;MAAA;MACAhF;QAAAL;MAAA,GACAK;QAAAJ;QAAAqF;QAAAX;UACAQ;QACA;MAAA,IACA9E,qFACAA;QAAAnB;QAAAmF;MAAA;IACA;IACA;MACA;QAAAV;MAAA;IACA;IACA;MAAAd;MAAAI;MAAAG;QACA;UACA;QACA;QACAwB;MACA;MAAAvB;MAAAH;IAAA;MAAAlD;IAAA;EACA;;;EC/FA;EACA;IACA;IACA;MACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;MACAuF;MACAC;MACAC;IACA;IACA;IACA;IACA;IACA;MACA;MACAC;MACA;MACAC;IACA;IACA;EACA;EACA;EACA;IACA;IACA;MACA;MACA;MACA;QACAC;QACAC;QACAC;MACA;IACA;EACA;;;;;;;ECrCA;IACA;IACA;IACAC;IACA;IACA;IACA;IACAtJ;MACA;MACA;QACA;QACAuJ;UACA;UACAC;YACA;UACA;UACA;QACA;MACA;IACA;IACA;MACAD;QACA;QACA;QACAvJ;UACA;YACA;UACA;QACA;QACA;QACA;UACAyJ;QACA;QACA;MACA;MACA;MACA;QACAH;MACA;IACA;IACA;MAAA;QAAAI;QAAAC;QAAAC;QAAAC;QAAAC;MAAA;MACA;QACA;QACA;QACAF;QACA;QACAG;UACAC;YACAC;YACAC,2DACAN,kCACA;UACA;UACAO;UACAC;UACAC;QACA;MACA,OACA;QACAN;QACA;UACAO;QACA;MACA;MACA;MACA;QACA;QACA;UACAC;QACA;MACA;IACA;IACA;IACA;IACAvK;MACA;QACAwK;MACA,OACA;QACA;QACA;UACAA;QACA;QACA;UACA;UACAC;UACAD;QACA;MACA;IACA;IACA;MACAT;QACA;QACA;UACA;QACA;QACA;UACAC;UACAG;UACAC;UACAC;QACA;MACA;IACA;IACA;MACAN;QACA;UACA;QACA;QACA;UACA;UACA;YAAAK;UAAA;QACA,OACA;UACA;UACA;YAAAA;UAAA;QACA;QACA;QACA;MACA;IACA;IACA;MACA;MACAL;MACA;QACAO;MACA;IACA;IACA;MACAf;QACA;QACA;UACA;QACA;QACA;QACA;QACA;MACA;IACA;IACA;MACA5G;MACA+H;MACAC;MACAC;MACAC;MACAC;MACAC;IACA;EACA;;;;;;;;;;EClJA;EACA;IAAA;MAAAtI;MAAA0H;MAAAa;MAAAC;MAAAC;MAAAC;MAAAC;MAAAC;MAAAC;IAAA;IACA;IACA;MACAnC;MACAoC;MACAnC;MACAC;IACA;IACA;IACA;IACA;IACA;MACA;MACAzF;QAAAkE;QAAAvE;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;MAAA,GACAK;QAAAL;MAAA,GACAiI;QAAAvE;MAAA;QAAAA;MAAA,2CACAuE;QAAA;MAAA,kBACAC;QAAAlI;QAAA;MAAA,oCACAK;QAAAqD;MAAA;QAAAa;QAAAvE;MAAA;IAAA;EACA;;;;;;;ECpBA;IAAA;MAAAmH;IAAA;IACA;IACA;IACA;IACA,mEACA1K;MAAAuD;IAAA,GACAK;MAAAL;MAAAyD;IAAA,GACApD;MAAAL;IAAA,GACAK;MAAAuG;MAAAkB;IAAA,wBACA;IACA;IACA;IACArL;MACA;QACA;MACA;MACA;QAAAiK;QAAAC;MAAA;MACAwB;MACAA;MACAA;MACA;MACA;MACA;QACA;QACAA;QACAA;QACAA;QACAA;QACAA;MACA;IACA;IACA;IACA1L;MACA;QACA0K;UACA;YACA;UACA;UACAgB;UACAA;QACA;MACA;IACA;IACA;MAAA1E;IAAA;EACA;;;;;;;EC3CA;EACA;EACA;IAAA;MAAAmD;MAAAxH;MAAA+H;MAAAiB;MAAAC;MAAAC;IAAA;IACA;IACA;IACA,qFACAF,aACAxB,OACA;IACA;IACA;MAAA5G;IAAA,GACAK,kGACAA;MAAAuG;MAAAe;MAAAC;MAAAC;IAAA,KACAxH;MAAAL;IAAA;MAAAuE;MAAA;MACArE;MAAAC;MAAAF;MAAAH;QACAwI;MACA;IAAA;MAAA/D;MAAA;MACAnE;MAAAF,kDACAmF,6BACAA;MAAAlF;MAAAF;MAAAH;QACAuI;MACA;IAAA;EACA;EACA;EACA;IAAA;MAAAE;MAAAnJ;MAAA+H;MAAAiB;MAAAC;MAAAC;IAAA;IACA;IACA;IACA;IACA;IACA,6BACAE,wCACAC;MAAAlE;MAAAqC;MAAAxH;MAAA+H;MAAAiB;MAAAC;MAAAC;IAAA;IACA;MACAI;QAAAnE;QAAAvE;MAAA;IACA;IACA;IACA;MAAAA;MAAA;IAAA,GACAK;MAAAL;IAAA,GACAK;MAAAH;MAAAD;MAAAJ;MAAAC;QACA6I;QACAC;MACA;IAAA,KACAvI;MAAAL;IAAA,GACAmH;MAAAnH;MAAA0D;IAAA;IACA;IACA;IACAmF;MAAA7I;MAAA0D;IAAA,0DACAgF,eACArI;MAAAL;IAAA,GACAK;MAAAH;MAAAD;MAAAJ;MAAAC;QACA6I;MACA;IAAA;EACA;;;;;;;ECpDA;IAAA;MAAAzJ;MAAA4J;MAAAC;MAAAC;MAAA7B;MAAAiB;MAAAa;MAAAC;MAAAZ;IAAA;IACA;IACA;IACAa;IACA;IACA;IACA;IACA;IACA1M;MACA;MACA;QACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACAuK;QACA;QACA;UACA;UACAoC;UACAD;QACA;MACA;MACA;MACA;QACA;MACA;IACA;IACA;IACA;IACA,2EACAhC,mBACA;IACA;IACA;IACA;IACA,oGACAiB,0CACA;IACA;MACA;QACA;UAAAX;UAAAb;UAAAmB;QAAA;MACA;MACA;QACA;UAAAN;UAAAb;UAAAgB;UAAAC;QAAA;MACA;MACA;MACA;QAAAJ;QAAAvI;QAAAwI;MAAA;IACA;IACA;IACA;IACA;MAAA1H;MAAA,iCACAqF,iDACAA;MAAA5B;IAAA,GACApD;MAAAL;MAAA;IAAA,GACA8I,aACAA,mFACAzI;MAAAL;IAAA,GACA;MAAAA;MAAA;IAAA,gCACAK,oGACA8G;MAAAnH;IAAA,GACAK;MAAAH;MAAAC;MAAAF;MAAAH;IAAA,uBACAkJ;MAAAhJ;IAAA,GACAK;MAAAH;MAAAC;MAAAF;MAAAH;IAAA;EACA;EACA;IAAA;MAAAZ;MAAAmK;MAAAd;MAAAe;MAAAlK;MAAA+H;MAAAiB;MAAAa;MAAAC;MAAAZ;IAAA;IACA;IACA;MAAAtI;MAAA;IAAA;MACA;MACA;QAAAuE;QAAAuE;QAAAC;QAAA7J;QAAA8J,oDACAT,+BACA;QAAApB;QAAAiB;QAAAa;QAAAC;QAAAZ;MAAA;IACA;EACA;;;;EC7EA;IAAA;MAAAiB;MAAAF;MAAA3E;MAAAC;MAAAC;MAAAvB;IAAA;IACA;IACA0B;IACA;MAAAiD;IAAA;IACA;MACA;MACA;MACA;QACA;QACA;UACA;QACA;QACA;MACA;MACA;MACA;MACA;MACAqB;QACA;QACA;QACA;UACA;UACA;YACA;UACA;UACA;UACA;YACA;UACA;UACA;QACA;QACA;QACA;UACAG;UACA3M;QACA;MACA;MACA;IACA;IACA;IACA;IACA;IACA;MAAAuC;MAAA+H;MAAAC;MAAAC;MAAAC;MAAAC;MAAAC;IAAA;MACAiC;QACA;UACA;QACA;QACA;QACAvD;QACA;MACA;IACA;IACA;IACAzJ;MACAsI;QAAA3F;MAAA;IACA;IACA;IACA;MAAAyD;MAAAC;MAAAtE;MAAA6E;MAAAD;QACA;QACA;QACAiG;UACAK;QACA;QACAD;QACA;QACA;QACA;UACA7E;QACA,OACA;UACA+E;QACA;MACA;MAAAzG;IAAA,GACA7C;MAAAkI;MAAAnJ;MAAA+H;MAAAiB;MAAAC;MAAAC;IAAA,IACAjI;MAAAnB;MAAAmK;MAAAd;MAAAe;MAAAlK;MAAA+H;MAAAiB;MAAAa;MAAAC;MAAAZ;IAAA,IACAjI;MAAA8G;IAAA;EACA;;;;;;;EC/EA;EACA;EACA;IACA;IACA;IACA;IACA;IACA;EACA;EACA;IAAA;MAAAoC;MAAAK;MAAAC;MAAAC;MAAAC;MAAAC;MAAAC;MAAAC;IAAA;IACA;IACA;IACA;IACA;IACA;IACA;MACA;MACA;MACAC;QACA;QACA;UACAC;QACA;MACA;MACA;QACArM;QACAQ;QACA8K;QACAgB;MACA;IACA;IACA;IACA;MACA;MACA;QACA;UACA;QACA;QACA;MACA;MACA;MACA;MACA,mCACAd,8CACA;IACA;IACA;IACA;IACA;IACA9M;MACA;QACA6N;MACA;IACA;IACA;IACA;IACA;IACAC;IACA9N;MACA;QACA8N;MACA;IACA;IACA;IACA;IACA9N;MACA;QACA+N;MACA;IACA;IACA;IACA;IACA;IACA/N;MACA;MACAgO;QAAArL;MAAA;QACA;QACA;UACA;QACA;;QACAsL;MACA;QACA;QACA;UACA;QACA;QACAC;MACA;QACA;QACA;UACA;QACA;QACAC;MACA;MACA;QACA;QACAxF;MACA;IACA;IACA;IACA;MACA;QACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA;IACA;IACA;MAAAvC;MAAAC;MAAAtE;MAAAuE;MAAAC;MAAAG;MAAAF;MAAAC,wCACA+G;MAAA7G;QACA;UACAyH;UACAX;QACA,OACA;UACAD;QACA;MACA;IAAA,GACA5J;MAAAL;IAAA,GACA8K;MAAA9K;MAAA0D;MAAAF;MAAAC;IAAA;MAAAzD;MAAA0D;IAAA,wBACArD;MAAAL;MAAA0D;IAAA,GACArD,8EACA,KACA0K,gBACA1K;MAAAL;IAAA,GACAK;MAAAL;MAAAgL;QAAAC;MAAA;IAAA;EACA;;;;;;ECtIA;IACA;IACA,qFACAC;IACA,qEACA;MACA,gFACAA;IACA;IACA;EACA;EASA;EACA;EACA;EACA;IAAA;MAAAC;MAAAjL;MAAAkL;IAAA;IACA;IACA;IACA;IACA;IACA3O;MACA;QACA4O;QACA;MACA;MACAC;QACA;UAAAC;UAAAJ;UAAAjL;UAAAsL;QAAA;QACA;QACA;QACA;QACA;QACA;UACAtF;QACA,OACA;UACAA;QACA;QACA;MACA;IACA;IACA;IACAzJ;MACA;QACA4O;QACA;MACA;MACA;QACAC;UACA;QACA;MACA;IACA;IACA;EACA;EACA;IACA;QAAA7G;QAAAgH;QAAA3B;QAAAC;QAAAC;QAAAE;QAAAnK;QAAA2L;MAAA;MAAAC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAlP;MACA;QACAmP;MACA;IACA;IACA;MACA;MACA,qCACAC;MACA,oBACAC;QACAC;QACAxD;QACAyD;QACA/N;MACA;IACA;IACA;IACA;MACA,uCACAgO;QACAlO;QACAQ;MACA,KACA0N;IACA;IACA;MAAAzP;IAAA;IACA;IACAkP;IACA;MACA;QAAAlP;MAAA,GACA6D;QAAAL;MAAA,GACAK;QAAAmE;QAAAC;QAAAC;QAAAC;UACAuH;QACA;QAAAtH;UACAuH;QACA;MAAA,IACAC;IACA;IACA;MACA;QAAA5P;MAAA,GACA6D;QAAAL;MAAA,GACAK;QAAAkJ;QAAAF;QAAA3E;QAAAC;UACAiH;QACA;QAAAhH;UACAyH;QACA;QAAAhJ;UACA;UACA8I;QACA;MAAA,IACAC;IACA;IACA;MAAA5P;IAAA,GACA6D;MAAAL;IAAA,GACAK;MAAAkJ;MAAAK;MAAAC;MAAAC;MAAAC;MAAAE,yBACA;QACA;QACAiC;QACAC;QACAP;QACAS;MACA,IACAC;MAAAtC;MAAAE;IAAA,IACAkC;EACA","names":["modules","module","__webpack_require__","enumerable","get","value","Object","resolve","step","reject","result","done","dataHandler","endHandler","stream","streamReader","readable","read","on","runReaderPump","errorHandler","removeListener","isStopped","pause","pausePromise","pauseResolver","resume","parseError","file","rowAccumulator","parseWarning","firstChunk","firstRows","isSingleLine","external_papaparse_default","chunkSize","preview","error","beforeFirstChunk","chunk","data","errors","firstWarning","nodeStream","parser","reportSuccess","complete","hasHeaders","papaParseConfig","fieldAssignments","fieldNames","record","skipLine","startIndex","processedCount","reportProgress","setTimeout","whenConsumed","disabled","onClick","children","className","type","label","small","focusOnly","external_react_default","general","goToPreviousStepTooltip","fileStep","initialDragDropPrompt","activeDragDropPrompt","getImportError","getDataFormatError","goBackButton","nextButton","rawFileContentsHeading","previewImportHeading","dataHasHeadersCheckbox","previewLoadingStatus","fieldsStep","stepSubtitle","requiredFieldsError","dragSourceAreaCaption","getDragSourcePageIndicator","getDragSourceActiveStatus","nextColumnsTooltip","previousColumnsTooltip","clearAssignmentTooltip","selectColumnTooltip","unselectColumnTooltip","dragTargetAreaCaption","getDragTargetOptionalCaption","getDragTargetRequiredCaption","dragTargetPlaceholder","getDragTargetAssignTooltip","dragTargetClearTooltip","columnCardDummyHeader","getColumnCardHeader","progressStep","uploadMoreButton","finishButton","statusError","statusComplete","statusPending","processedRowsLabel","fileName","subtitle","secondaryDisabled","secondaryLabel","nextDisabled","nextLabel","onSecondary","onNext","onCancel","subtitleRef","titleRef","tabIndex","ref","role","onSelected","onSelectedRef","getRootProps","getInputProps","isDragActive","onDrop","onCancelClick","warning","chunkSlice","chunkHasMore","rows","headerRow","key","customConfig","assumeNoHeaders","prevState","onChange","onAccept","customConfigRef","assumeNoHeadersRef","onChangeRef","setPreview","parsePreview","setPapaParseConfig","setHasHeaders","asyncLockRef","l10n","checked","digitCount","base","next","remainder","digits","index","header","values","onTouchedRef","setFieldAssignments","removedFieldNames","copy","first","last","event","xy","args","setDragState","pointerStartInfo","initialXY","initialWidth","column","dropFieldName","updateListeners","internalAssignHandler","listeners","document","clearTimeout","dragState","dragEventBinder","dragHoverHandler","columnSelectHandler","assignHandler","unassignHandler","rowCount","hasError","isAssigned","isShadow","isDraggable","isDragged","isDropIndicator","code","isDummy","headerValue","dragBoxRef","eventBinder","onSelect","onUnassign","columns","slice","map","pageContents","setPage","setPageChanged","pageCount","field","touched","assignedColumn","onHover","onAssign","onHoverRef","isHoveredRef","fields","fieldTouched","fileState","assignedColumnIndexes","setFieldTouched","fullTouchedMap","setValidationError","fieldsState","externalPreview","processChunk","onStart","onComplete","onRestart","onClose","fieldList","columnSparseList","columnFields","onStartRef","onCompleteRef","statusRef","processFile","setProgressCount","setIsComplete","setError","setIsDismissed","isComplete","progressCount","style","width","t","name","optional","console","fieldSetter","id","isOptional","restartable","locale","customPapaParseConfig","setFieldsState","generatePreviewColumns","externalColumns","rawData","skipHeaders","content","setFileState","setFileAccepted","contentWrap","setFieldsAccepted","undefined"],"sources":["webpack:///webpack/bootstrap","webpack:///src/components/TextButton.scss?9052","webpack:///src/components/IconButton.scss?8012","webpack:///src/components/ImporterFrame.scss?9c61","webpack:///src/components/file-step/FileSelector.scss?dd56","webpack:///src/components/file-step/FormatErrorMessage.scss?898f","webpack:///src/components/file-step/FormatRawPreview.scss?0237","webpack:///src/components/file-step/FormatDataRowPreview.scss?bb3a","webpack:///src/components/file-step/FileStep.scss?8c88","webpack:///src/components/fields-step/ColumnDragCard.scss?0c54","webpack:///src/components/fields-step/ColumnDragObject.scss?1da5","webpack:///src/components/fields-step/ColumnDragSourceArea.scss?fdb8","webpack:///src/components/fields-step/ColumnDragTargetArea.scss?aac4","webpack:///src/components/ProgressDisplay.scss?6ad0","webpack:///src/components/Importer.scss?f3ca","webpack:///src/parser.ts","webpack:///src/components/TextButton.tsx","webpack:///src/components/IconButton.tsx","webpack:///src/locale/index.ts","webpack:///src/locale/LocaleContext.tsx","webpack:///src/components/ImporterFrame.tsx","webpack:///src/components/file-step/FileSelector.tsx","webpack:///src/components/file-step/FormatErrorMessage.tsx","webpack:///src/components/file-step/FormatRawPreview.tsx","webpack:///src/components/file-step/FormatDataRowPreview.tsx","webpack:///src/components/file-step/FileStep.tsx","webpack:///src/components/fields-step/ColumnPreview.tsx","webpack:///src/components/fields-step/ColumnDragState.tsx","webpack:///src/components/fields-step/ColumnDragCard.tsx","webpack:///src/components/fields-step/ColumnDragObject.tsx","webpack:///src/components/fields-step/ColumnDragSourceArea.tsx","webpack:///src/components/fields-step/ColumnDragTargetArea.tsx","webpack:///src/components/fields-step/FieldsStep.tsx","webpack:///src/components/ProgressDisplay.tsx","webpack:///src/components/Importer.tsx"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 19);\n","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport Papa from 'papaparse';\r\nexport const PREVIEW_ROW_COUNT = 5;\r\n// polyfill as implemented in https://github.com/eligrey/Blob.js/blob/master/Blob.js#L653\r\n// (this is for Safari pre v14.1)\r\nfunction streamForBlob(blob) {\r\n    if (blob.stream) {\r\n        return blob.stream();\r\n    }\r\n    const res = new Response(blob);\r\n    if (res.body) {\r\n        return res.body;\r\n    }\r\n    throw new Error('This browser does not support client-side file reads');\r\n}\r\n// incredibly cheap wrapper exposing a subset of stream.Readable interface just for PapaParse usage\r\n// @todo chunk size\r\nfunction nodeStreamWrapper(stream, encoding) {\r\n    let dataHandler = null;\r\n    let endHandler = null;\r\n    let errorHandler = null;\r\n    let isStopped = false;\r\n    let pausePromise = null;\r\n    let pauseResolver = null;\r\n    function runReaderPump() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // ensure this is truly in the next tick after uncorking\r\n            yield Promise.resolve();\r\n            const streamReader = stream.getReader();\r\n            const decoder = new TextDecoder(encoding); // this also strips BOM by default\r\n            try {\r\n                // main reader pump loop\r\n                while (!isStopped) {\r\n                    // perform read from upstream\r\n                    const { done, value } = yield streamReader.read();\r\n                    // wait if we became paused since last data event\r\n                    if (pausePromise) {\r\n                        yield pausePromise;\r\n                    }\r\n                    // check again if stopped and unlistened\r\n                    if (isStopped || !dataHandler || !endHandler) {\r\n                        return;\r\n                    }\r\n                    // final data flush and end notification\r\n                    if (done) {\r\n                        const lastChunkString = decoder.decode(value); // value is empty but pass just in case\r\n                        if (lastChunkString) {\r\n                            dataHandler(lastChunkString);\r\n                        }\r\n                        endHandler(undefined);\r\n                        return;\r\n                    }\r\n                    // otherwise, normal data event after stream-safe decoding\r\n                    const chunkString = decoder.decode(value, { stream: true });\r\n                    dataHandler(chunkString);\r\n                }\r\n            }\r\n            finally {\r\n                // always release the lock\r\n                streamReader.releaseLock();\r\n            }\r\n        });\r\n    }\r\n    const self = {\r\n        // marker properties to make PapaParse think this is a Readable object\r\n        readable: true,\r\n        read() {\r\n            throw new Error('only flowing mode is emulated');\r\n        },\r\n        on(event, callback) {\r\n            switch (event) {\r\n                case 'data':\r\n                    if (dataHandler) {\r\n                        throw new Error('two data handlers not supported');\r\n                    }\r\n                    dataHandler = callback;\r\n                    // flowing state started, run the main pump loop\r\n                    runReaderPump().catch((error) => {\r\n                        if (errorHandler) {\r\n                            errorHandler(error);\r\n                        }\r\n                        else {\r\n                            // rethrow to show error in console\r\n                            throw error;\r\n                        }\r\n                    });\r\n                    return;\r\n                case 'end':\r\n                    if (endHandler) {\r\n                        throw new Error('two end handlers not supported');\r\n                    }\r\n                    endHandler = callback;\r\n                    return;\r\n                case 'error':\r\n                    if (errorHandler) {\r\n                        throw new Error('two error handlers not supported');\r\n                    }\r\n                    errorHandler = callback;\r\n                    return;\r\n            }\r\n            throw new Error('unknown stream shim event: ' + event);\r\n        },\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        removeListener(event, callback) {\r\n            // stop and clear everything for simplicity\r\n            isStopped = true;\r\n            dataHandler = null;\r\n            endHandler = null;\r\n            errorHandler = null;\r\n        },\r\n        pause() {\r\n            if (!pausePromise) {\r\n                pausePromise = new Promise((resolve) => {\r\n                    pauseResolver = resolve;\r\n                });\r\n            }\r\n            return self;\r\n        },\r\n        resume() {\r\n            if (pauseResolver) {\r\n                pauseResolver(); // waiting code will proceed in next tick\r\n                pausePromise = null;\r\n                pauseResolver = null;\r\n            }\r\n            return self;\r\n        }\r\n    };\r\n    // pass ourselves off as a real Node stream\r\n    return self;\r\n}\r\nexport function parsePreview(file, customConfig) {\r\n    // wrap synchronous errors in promise\r\n    return new Promise((resolve) => {\r\n        let firstChunk = null;\r\n        let firstWarning = undefined;\r\n        const rowAccumulator = [];\r\n        function reportSuccess() {\r\n            // PapaParse normally complains first anyway, but might as well flag it\r\n            if (rowAccumulator.length === 0) {\r\n                return {\r\n                    parseError: new Error('File is empty'),\r\n                    file\r\n                };\r\n            }\r\n            // remember whether this file has only one line\r\n            const isSingleLine = rowAccumulator.length === 1;\r\n            // fill preview with blanks if needed\r\n            while (rowAccumulator.length < PREVIEW_ROW_COUNT) {\r\n                rowAccumulator.push([]);\r\n            }\r\n            resolve({\r\n                file,\r\n                parseError: undefined,\r\n                parseWarning: firstWarning || undefined,\r\n                firstChunk: firstChunk || '',\r\n                firstRows: rowAccumulator,\r\n                isSingleLine\r\n            });\r\n        }\r\n        // use our own multibyte-safe streamer, bail after first chunk\r\n        // (this used to add skipEmptyLines but that was hiding possible parse errors)\r\n        // @todo wait for upstream multibyte fix in PapaParse: https://github.com/mholt/PapaParse/issues/908\r\n        const nodeStream = nodeStreamWrapper(streamForBlob(file), customConfig.encoding || 'utf-8');\r\n        Papa.parse(nodeStream, Object.assign(Object.assign({}, customConfig), { chunkSize: 10000, preview: PREVIEW_ROW_COUNT, error: (error) => {\r\n                resolve({\r\n                    parseError: error,\r\n                    file\r\n                });\r\n            }, beforeFirstChunk: (chunk) => {\r\n                firstChunk = chunk;\r\n            }, chunk: ({ data, errors }, parser) => {\r\n                data.forEach((row) => {\r\n                    const stringRow = row.map((item) => typeof item === 'string' ? item : '');\r\n                    rowAccumulator.push(stringRow);\r\n                });\r\n                if (errors.length > 0 && !firstWarning) {\r\n                    firstWarning = errors[0];\r\n                }\r\n                // finish parsing once we got enough data, otherwise try for more\r\n                // (in some cases PapaParse flushes out last line as separate chunk)\r\n                if (rowAccumulator.length >= PREVIEW_ROW_COUNT) {\r\n                    nodeStream.pause(); // parser does not pause source stream, do it here explicitly\r\n                    parser.abort();\r\n                    reportSuccess();\r\n                }\r\n            }, complete: reportSuccess }));\r\n    }).catch((error) => {\r\n        return {\r\n            parseError: error,\r\n            file\r\n        };\r\n    });\r\n}\r\nexport function processFile(input, reportProgress, callback) {\r\n    const { file, hasHeaders, papaParseConfig, fieldAssignments } = input;\r\n    const fieldNames = Object.keys(fieldAssignments);\r\n    // wrap synchronous errors in promise\r\n    return new Promise((resolve, reject) => {\r\n        // skip first line if needed\r\n        let skipLine = hasHeaders;\r\n        let processedCount = 0;\r\n        // use our own multibyte-safe decoding streamer\r\n        // @todo wait for upstream multibyte fix in PapaParse: https://github.com/mholt/PapaParse/issues/908\r\n        const nodeStream = nodeStreamWrapper(streamForBlob(file), papaParseConfig.encoding || 'utf-8');\r\n        Papa.parse(nodeStream, Object.assign(Object.assign({}, papaParseConfig), { chunkSize: papaParseConfig.chunkSize || 10000, error: (error) => {\r\n                reject(error);\r\n            }, chunk: ({ data }, parser) => {\r\n                // pause to wait until the rows are consumed\r\n                nodeStream.pause(); // parser does not pause source stream, do it here explicitly\r\n                parser.pause();\r\n                const skipped = skipLine && data.length > 0;\r\n                const rows = (skipped ? data.slice(1) : data).map((row) => {\r\n                    const stringRow = row.map((item) => typeof item === 'string' ? item : '');\r\n                    const record = {};\r\n                    fieldNames.forEach((fieldName) => {\r\n                        const columnIndex = fieldAssignments[fieldName];\r\n                        if (columnIndex !== undefined) {\r\n                            record[fieldName] = stringRow[columnIndex];\r\n                        }\r\n                    });\r\n                    return record; // @todo look into a more precise setup\r\n                });\r\n                // clear line skip flag if there was anything to skip\r\n                if (skipped) {\r\n                    skipLine = false;\r\n                }\r\n                // info snapshot for processing callback\r\n                const info = {\r\n                    startIndex: processedCount\r\n                };\r\n                processedCount += rows.length;\r\n                // @todo collect errors\r\n                reportProgress(rows.length);\r\n                // wrap sync errors in promise\r\n                // (avoid invoking callback if there are no rows to consume)\r\n                const whenConsumed = new Promise((resolve) => {\r\n                    const result = rows.length ? callback(rows, info) : undefined;\r\n                    // introduce delay to allow a frame render\r\n                    setTimeout(() => resolve(result), 0);\r\n                });\r\n                // unpause parsing when done\r\n                whenConsumed.then(() => {\r\n                    nodeStream.resume();\r\n                    parser.resume();\r\n                }, () => {\r\n                    // @todo collect errors\r\n                    nodeStream.resume();\r\n                    parser.resume();\r\n                });\r\n            }, complete: () => {\r\n                resolve();\r\n            } }));\r\n    });\r\n}\r\n","import React from 'react';\r\nimport './TextButton.scss';\r\nexport const TextButton = ({ disabled, onClick, children }) => {\r\n    return (React.createElement(\"button\", { className: \"CSVImporter_TextButton\", disabled: disabled, onClick: onClick }, children));\r\n};\r\n","import React from 'react';\r\nimport './IconButton.scss';\r\nexport const IconButton = ({ type, label, small, focusOnly, disabled, onClick }) => {\r\n    return (React.createElement(\"button\", { className: \"CSVImporter_IconButton\", \"aria-label\": label, disabled: disabled, onClick: onClick, \"data-small\": !!small, \"data-focus-only\": !!focusOnly },\r\n        React.createElement(\"span\", { \"data-type\": type })));\r\n};\r\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types -- all exports are ImporterLocale which is already fully typed */\r\nexport const enUS = {\r\n    general: {\r\n        goToPreviousStepTooltip: 'Go to previous step'\r\n    },\r\n    fileStep: {\r\n        initialDragDropPrompt: 'Drag-and-drop CSV file here, or click to select in folder',\r\n        activeDragDropPrompt: 'Drop CSV file here...',\r\n        getImportError: (message) => `Import error: ${message}`,\r\n        getDataFormatError: (message) => `Please check data formatting: ${message}`,\r\n        goBackButton: 'Go Back',\r\n        nextButton: 'Choose columns',\r\n        rawFileContentsHeading: 'Raw File Contents',\r\n        previewImportHeading: 'Preview Import',\r\n        dataHasHeadersCheckbox: 'Data has headers',\r\n        previewLoadingStatus: 'Loading preview...'\r\n    },\r\n    fieldsStep: {\r\n        stepSubtitle: 'Select Columns',\r\n        requiredFieldsError: 'Please assign all required fields',\r\n        nextButton: 'Import',\r\n        dragSourceAreaCaption: 'Columns to import',\r\n        getDragSourcePageIndicator: (currentPage, pageCount) => `Page ${currentPage} of ${pageCount}`,\r\n        getDragSourceActiveStatus: (columnCode) => `Assigning column ${columnCode}`,\r\n        nextColumnsTooltip: 'Show next columns',\r\n        previousColumnsTooltip: 'Show previous columns',\r\n        clearAssignmentTooltip: 'Clear column assignment',\r\n        selectColumnTooltip: 'Select column for assignment',\r\n        unselectColumnTooltip: 'Unselect column',\r\n        dragTargetAreaCaption: 'Target fields',\r\n        getDragTargetOptionalCaption: (field) => `${field} (optional)`,\r\n        getDragTargetRequiredCaption: (field) => `${field} (required)`,\r\n        dragTargetPlaceholder: 'Drag column here',\r\n        getDragTargetAssignTooltip: (columnCode) => `Assign column ${columnCode}`,\r\n        dragTargetClearTooltip: 'Clear column assignment',\r\n        columnCardDummyHeader: 'Unassigned field',\r\n        getColumnCardHeader: (code) => `Column ${code}`\r\n    },\r\n    progressStep: {\r\n        stepSubtitle: 'Import',\r\n        uploadMoreButton: 'Upload More',\r\n        finishButton: 'Finish',\r\n        statusError: 'Could not import',\r\n        statusComplete: 'Complete',\r\n        statusPending: 'Importing...',\r\n        processedRowsLabel: 'Processed rows:'\r\n    }\r\n};\r\nexport const deDE = {\r\n    general: {\r\n        goToPreviousStepTooltip: 'Zum vorherigen Schritt'\r\n    },\r\n    fileStep: {\r\n        initialDragDropPrompt: 'CSV-Datei auf dieses Feld ziehen, oder klicken um eine Datei auszuwählen',\r\n        activeDragDropPrompt: 'CSV-Datei auf dieses Feld ziehen...',\r\n        nextButton: 'Spalten auswählen',\r\n        getImportError: (message) => `Fehler beim Import: ${message}`,\r\n        getDataFormatError: (message) => `Bitte Datenformat überprüfen: ${message}`,\r\n        goBackButton: 'Zurück',\r\n        rawFileContentsHeading: 'Originaler Datei-Inhalt',\r\n        previewImportHeading: 'Import-Vorschau',\r\n        dataHasHeadersCheckbox: 'Mit Kopfzeile',\r\n        previewLoadingStatus: 'Vorschau wird geladen...'\r\n    },\r\n    fieldsStep: {\r\n        stepSubtitle: 'Spalten auswählen',\r\n        requiredFieldsError: 'Bitte weise allen nicht optionalen Spalten einen Wert zu',\r\n        nextButton: 'Importieren',\r\n        dragSourceAreaCaption: 'Zu importierende Spalte',\r\n        getDragSourcePageIndicator: (currentPage, pageCount) => `Seite ${currentPage} von ${pageCount}`,\r\n        getDragSourceActiveStatus: (columnCode) => `Spalte ${columnCode} zuweisen`,\r\n        nextColumnsTooltip: 'Nächste Spalten anzeigen',\r\n        previousColumnsTooltip: 'Vorherige Spalten anzeigen',\r\n        clearAssignmentTooltip: 'Zugewiesene Spalte entfernen',\r\n        selectColumnTooltip: 'Spalte zum Zuweisen auswählen',\r\n        unselectColumnTooltip: 'Spalte abwählen',\r\n        dragTargetAreaCaption: 'Zielfelder',\r\n        getDragTargetOptionalCaption: (field) => `${field} (optional)`,\r\n        getDragTargetRequiredCaption: (field) => `${field} (erforderlich)`,\r\n        dragTargetPlaceholder: 'Spalte hierher ziehen',\r\n        getDragTargetAssignTooltip: (columnCode) => `Spalte ${columnCode} zuweisen`,\r\n        dragTargetClearTooltip: 'Zugewiesene Spalte entfernen',\r\n        columnCardDummyHeader: 'Nicht zugewiesenes Feld',\r\n        getColumnCardHeader: (code) => `Spalte ${code}`\r\n    },\r\n    progressStep: {\r\n        stepSubtitle: 'Importieren',\r\n        uploadMoreButton: 'Weitere hochladen',\r\n        finishButton: 'Abschließen',\r\n        statusError: 'Konnte nicht importiert werden',\r\n        statusComplete: 'Fertig',\r\n        statusPending: 'Wird importiert...',\r\n        processedRowsLabel: 'Verarbeitete Zeilen:'\r\n    }\r\n};\r\n","import React from 'react';\r\nimport { enUS } from '.';\r\nimport { useContext } from 'react';\r\nexport const LocaleContext = React.createContext(enUS);\r\nexport function useLocale(namespace) {\r\n    const locale = useContext(LocaleContext);\r\n    return locale[namespace]; // not using memo for basic property getter\r\n}\r\n","import React, { useRef, useEffect } from 'react';\r\nimport { TextButton } from './TextButton';\r\nimport { IconButton } from './IconButton';\r\nimport './ImporterFrame.scss';\r\nimport { useLocale } from '../locale/LocaleContext';\r\nexport const ImporterFrame = ({ fileName, subtitle, secondaryDisabled, secondaryLabel, nextDisabled, nextLabel, error, onSecondary, onNext, onCancel, children }) => {\r\n    const titleRef = useRef(null);\r\n    const subtitleRef = useRef(null);\r\n    useEffect(() => {\r\n        if (subtitleRef.current) {\r\n            subtitleRef.current.focus();\r\n        }\r\n        else if (titleRef.current) {\r\n            titleRef.current.focus();\r\n        }\r\n    }, []);\r\n    const l10n = useLocale('general');\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame\" },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__header\" },\r\n            React.createElement(IconButton, { label: l10n.goToPreviousStepTooltip, type: \"arrowBack\", disabled: !onCancel, onClick: onCancel }),\r\n            React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerTitle\", tabIndex: -1, ref: titleRef }, fileName),\r\n            subtitle ? (React.createElement(React.Fragment, null,\r\n                React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerCrumbSeparator\" },\r\n                    React.createElement(\"span\", null)),\r\n                React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerSubtitle\", tabIndex: -1, ref: subtitleRef }, subtitle))) : null),\r\n        children,\r\n        React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footer\" },\r\n            React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerFill\" }),\r\n            error ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerError\", role: \"status\" }, error)) : null,\r\n            secondaryLabel ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerSecondary\" },\r\n                React.createElement(TextButton, { disabled: !!secondaryDisabled, onClick: onSecondary }, secondaryLabel))) : null,\r\n            nextLabel !== false ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerNext\" },\r\n                React.createElement(TextButton, { disabled: !!nextDisabled, onClick: onNext }, nextLabel))) : null)));\r\n};\r\n","import React, { useCallback, useRef } from 'react';\r\nimport { useDropzone } from 'react-dropzone';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nimport './FileSelector.scss';\r\nexport const FileSelector = ({ onSelected }) => {\r\n    const onSelectedRef = useRef(onSelected);\r\n    onSelectedRef.current = onSelected;\r\n    const dropHandler = useCallback((acceptedFiles) => {\r\n        // silently ignore if nothing to do\r\n        if (acceptedFiles.length < 1) {\r\n            return;\r\n        }\r\n        const file = acceptedFiles[0];\r\n        onSelectedRef.current(file);\r\n    }, []);\r\n    const { getRootProps, getInputProps, isDragActive } = useDropzone({\r\n        onDrop: dropHandler\r\n    });\r\n    const l10n = useLocale('fileStep');\r\n    return (React.createElement(\"div\", Object.assign({ className: \"CSVImporter_FileSelector\", \"data-active\": !!isDragActive }, getRootProps()),\r\n        React.createElement(\"input\", Object.assign({}, getInputProps())),\r\n        isDragActive ? (React.createElement(\"span\", null, l10n.activeDragDropPrompt)) : (React.createElement(\"span\", null, l10n.initialDragDropPrompt))));\r\n};\r\n","import React from 'react';\r\nimport { TextButton } from '../TextButton';\r\nimport './FormatErrorMessage.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nexport const FormatErrorMessage = React.memo(({ onCancelClick, children }) => {\r\n    const l10n = useLocale('fileStep');\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatErrorMessage\" },\r\n        React.createElement(\"span\", null, children),\r\n        React.createElement(TextButton, { onClick: onCancelClick }, l10n.goBackButton)));\r\n});\r\n","import React from 'react';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nimport { FormatErrorMessage } from './FormatErrorMessage';\r\nimport './FormatRawPreview.scss';\r\nconst RAW_PREVIEW_SIZE = 500;\r\nexport const FormatRawPreview = React.memo(({ chunk, warning, onCancelClick }) => {\r\n    const chunkSlice = chunk.slice(0, RAW_PREVIEW_SIZE);\r\n    const chunkHasMore = chunk.length > RAW_PREVIEW_SIZE;\r\n    const l10n = useLocale('fileStep');\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatRawPreview\" },\r\n        React.createElement(\"div\", { className: \"CSVImporter_FormatRawPreview__scroll\" },\r\n            React.createElement(\"pre\", { className: \"CSVImporter_FormatRawPreview__pre\" },\r\n                chunkSlice,\r\n                chunkHasMore && React.createElement(\"aside\", null, \"...\"))),\r\n        warning ? (React.createElement(FormatErrorMessage, { onCancelClick: onCancelClick }, l10n.getDataFormatError(warning.message || String(warning)))) : null));\r\n});\r\n","import React from 'react';\r\nimport './FormatDataRowPreview.scss';\r\nexport const FormatDataRowPreview = React.memo(({ hasHeaders, rows }) => {\r\n    const headerRow = hasHeaders ? rows[0] : null;\r\n    const bodyRows = hasHeaders ? rows.slice(1) : rows;\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatDataRowPreview\" },\r\n        React.createElement(\"table\", { className: \"CSVImporter_FormatDataRowPreview__table\" },\r\n            headerRow && (React.createElement(\"thead\", null,\r\n                React.createElement(\"tr\", null, headerRow.map((item, itemIndex) => (React.createElement(\"th\", { key: itemIndex }, item)))))),\r\n            React.createElement(\"tbody\", null, bodyRows.map((row, rowIndex) => (React.createElement(\"tr\", { key: rowIndex }, row.map((item, itemIndex) => (React.createElement(\"td\", { key: itemIndex }, item))))))))));\r\n});\r\n","import React, { useMemo, useRef, useEffect, useState } from 'react';\r\nimport { parsePreview } from '../../parser';\r\nimport { ImporterFrame } from '../ImporterFrame';\r\nimport { FileSelector } from './FileSelector';\r\nimport { FormatRawPreview } from './FormatRawPreview';\r\nimport { FormatDataRowPreview } from './FormatDataRowPreview';\r\nimport { FormatErrorMessage } from './FormatErrorMessage';\r\nimport './FileStep.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nexport const FileStep = ({ customConfig, assumeNoHeaders, prevState, onChange, onAccept }) => {\r\n    // seed from previous state as needed\r\n    const [selectedFile, setSelectedFile] = useState(prevState ? prevState.file : null);\r\n    const [preview, setPreview] = useState(() => prevState && Object.assign({ parseError: undefined }, prevState));\r\n    const [papaParseConfig, setPapaParseConfig] = useState(prevState ? prevState.papaParseConfig : customConfig);\r\n    const [hasHeaders, setHasHeaders] = useState(prevState ? prevState.hasHeaders : false);\r\n    // wrap in ref to avoid triggering effect\r\n    const customConfigRef = useRef(customConfig);\r\n    customConfigRef.current = customConfig;\r\n    const assumeNoHeadersRef = useRef(assumeNoHeaders);\r\n    assumeNoHeadersRef.current = assumeNoHeaders;\r\n    const onChangeRef = useRef(onChange);\r\n    onChangeRef.current = onChange;\r\n    // notify of current state\r\n    useEffect(() => {\r\n        onChangeRef.current(preview && !preview.parseError\r\n            ? Object.assign(Object.assign({}, preview), { papaParseConfig, hasHeaders }) : null);\r\n    }, [preview, papaParseConfig, hasHeaders]);\r\n    // perform async preview parse once for the given file\r\n    const asyncLockRef = useRef(0);\r\n    useEffect(() => {\r\n        // clear other state when file selector is reset\r\n        if (!selectedFile) {\r\n            setPreview(null);\r\n            return;\r\n        }\r\n        // preserve existing state when parsing for this file is already complete\r\n        if (preview && preview.file === selectedFile) {\r\n            return;\r\n        }\r\n        const oplock = asyncLockRef.current;\r\n        // lock in the current PapaParse config instance for use in multiple spots\r\n        const config = customConfigRef.current;\r\n        // kick off the preview parse\r\n        parsePreview(selectedFile, config).then((results) => {\r\n            // ignore if stale\r\n            if (oplock !== asyncLockRef.current) {\r\n                return;\r\n            }\r\n            // save the results and the original config\r\n            setPreview(results);\r\n            setPapaParseConfig(config);\r\n            // pre-fill headers flag (only possible with >1 lines)\r\n            setHasHeaders(results.parseError\r\n                ? false\r\n                : !assumeNoHeadersRef.current && !results.isSingleLine);\r\n        });\r\n        return () => {\r\n            // invalidate current oplock on change or unmount\r\n            asyncLockRef.current += 1;\r\n        };\r\n    }, [selectedFile, preview]);\r\n    const l10n = useLocale('fileStep');\r\n    // clear selected file\r\n    // preview result content to display\r\n    const reportBlock = useMemo(() => {\r\n        if (!preview) {\r\n            return null;\r\n        }\r\n        if (preview.parseError) {\r\n            return (React.createElement(\"div\", { className: \"CSVImporter_FileStep__mainResultBlock\" },\r\n                React.createElement(FormatErrorMessage, { onCancelClick: () => setSelectedFile(null) }, l10n.getImportError(preview.parseError.message || String(preview.parseError)))));\r\n        }\r\n        return (React.createElement(\"div\", { className: \"CSVImporter_FileStep__mainResultBlock\" },\r\n            React.createElement(\"div\", { className: \"CSVImporter_FileStep__header\" }, l10n.rawFileContentsHeading),\r\n            React.createElement(FormatRawPreview, { chunk: preview.firstChunk, warning: preview.parseWarning, onCancelClick: () => setSelectedFile(null) }),\r\n            preview.parseWarning ? null : (React.createElement(React.Fragment, null,\r\n                React.createElement(\"div\", { className: \"CSVImporter_FileStep__header\" },\r\n                    l10n.previewImportHeading,\r\n                    !preview.isSingleLine && ( // hide setting if only one line anyway\r\n                    React.createElement(\"label\", { className: \"CSVImporter_FileStep__headerToggle\" },\r\n                        React.createElement(\"input\", { type: \"checkbox\", checked: hasHeaders, onChange: () => {\r\n                                setHasHeaders((prev) => !prev);\r\n                            } }),\r\n                        React.createElement(\"span\", null, l10n.dataHasHeadersCheckbox)))),\r\n                React.createElement(FormatDataRowPreview, { hasHeaders: hasHeaders, rows: preview.firstRows })))));\r\n    }, [preview, hasHeaders, l10n]);\r\n    if (!selectedFile) {\r\n        return React.createElement(FileSelector, { onSelected: (file) => setSelectedFile(file) });\r\n    }\r\n    return (React.createElement(ImporterFrame, { fileName: selectedFile.name, nextDisabled: !preview || !!preview.parseError || !!preview.parseWarning, onNext: () => {\r\n            if (!preview || preview.parseError) {\r\n                throw new Error('unexpected missing preview info');\r\n            }\r\n            onAccept();\r\n        }, onCancel: () => setSelectedFile(null), nextLabel: l10n.nextButton }, reportBlock || (React.createElement(\"div\", { className: \"CSVImporter_FileStep__mainPendingBlock\" }, l10n.previewLoadingStatus))));\r\n};\r\n","// spreadsheet-style column code computation (A, B, ..., Z, AA, AB, ..., etc)\r\nexport function generateColumnCode(value) {\r\n    // ignore dummy index\r\n    if (value < 0) {\r\n        return '';\r\n    }\r\n    // first, determine how many base-26 letters there should be\r\n    // (because the notation is not purely positional)\r\n    let digitCount = 1;\r\n    let base = 0;\r\n    let next = 26;\r\n    while (next <= value) {\r\n        digitCount += 1;\r\n        base = next;\r\n        next = next * 26 + 26;\r\n    }\r\n    // then, apply normal positional digit computation on remainder above base\r\n    let remainder = value - base;\r\n    const digits = [];\r\n    while (digits.length < digitCount) {\r\n        const lastDigit = remainder % 26;\r\n        remainder = Math.floor((remainder - lastDigit) / 26); // applying floor just in case\r\n        // store ASCII code, with A as 0\r\n        digits.unshift(65 + lastDigit);\r\n    }\r\n    return String.fromCharCode.apply(null, digits);\r\n}\r\n// prepare spreadsheet-like column display information for given raw data preview\r\nexport function generatePreviewColumns(firstRows, hasHeaders) {\r\n    const columnStubs = [...new Array(firstRows[0].length)];\r\n    return columnStubs.map((empty, index) => {\r\n        const values = firstRows.map((row) => row[index] || '');\r\n        const headerValue = hasHeaders ? values.shift() : undefined;\r\n        return {\r\n            index,\r\n            header: headerValue,\r\n            values\r\n        };\r\n    });\r\n}\r\n","import { useState, useCallback, useEffect, useRef } from 'react';\r\nimport { useDrag } from 'react-use-gesture';\r\nexport function useColumnDragState(fields, initialAssignments, onTouched) {\r\n    // wrap in ref to avoid re-triggering\r\n    const onTouchedRef = useRef(onTouched);\r\n    onTouchedRef.current = onTouched;\r\n    const [dragState, setDragState] = useState(null);\r\n    const [fieldAssignments, setFieldAssignments] = useState(initialAssignments);\r\n    // make sure there are no extra fields\r\n    useEffect(() => {\r\n        const removedFieldNames = Object.keys(fieldAssignments).filter((existingFieldName) => !fields.some((field) => field.name === existingFieldName));\r\n        if (removedFieldNames.length > 0) {\r\n            // @todo put everything inside this setter\r\n            setFieldAssignments((prev) => {\r\n                const copy = Object.assign({}, prev);\r\n                removedFieldNames.forEach((fieldName) => {\r\n                    delete copy[fieldName];\r\n                });\r\n                return copy;\r\n            });\r\n        }\r\n    }, [fields, fieldAssignments]);\r\n    const internalAssignHandler = useCallback((column, fieldName) => {\r\n        setFieldAssignments((prevAssignments) => {\r\n            const copy = Object.assign({}, prevAssignments);\r\n            // ensure dropped column does not show up elsewhere\r\n            Object.keys(prevAssignments).forEach((name) => {\r\n                if (copy[name] === column.index) {\r\n                    delete copy[name];\r\n                }\r\n            });\r\n            // set new field column\r\n            if (fieldName !== null) {\r\n                copy[fieldName] = column.index;\r\n            }\r\n            return copy;\r\n        });\r\n        // mark for validation display\r\n        if (fieldName) {\r\n            onTouchedRef.current(fieldName);\r\n        }\r\n    }, []);\r\n    const bindDrag = useDrag(({ first, last, event, xy, args }) => {\r\n        if (first && event) {\r\n            // only prevent default inside first event\r\n            // (touchmove uses passive event handler and would trigger warning)\r\n            event.preventDefault();\r\n            const [column, startFieldName] = args;\r\n            setDragState({\r\n                pointerStartInfo: {\r\n                    initialXY: xy,\r\n                    initialWidth: event.currentTarget instanceof HTMLElement\r\n                        ? event.currentTarget.offsetWidth\r\n                        : 0\r\n                },\r\n                column,\r\n                dropFieldName: startFieldName !== undefined ? startFieldName : null,\r\n                updateListeners: {}\r\n            });\r\n        }\r\n        else if (last) {\r\n            setDragState(null);\r\n            if (dragState) {\r\n                internalAssignHandler(dragState.column, dragState.dropFieldName);\r\n            }\r\n        }\r\n        // @todo figure out a cleaner event stream solution\r\n        if (dragState) {\r\n            const listeners = dragState.updateListeners;\r\n            for (const key of Object.keys(listeners)) {\r\n                listeners[key](xy);\r\n            }\r\n        }\r\n    }, {});\r\n    // when dragging, set root-level user-select:none to prevent text selection, see Importer.scss\r\n    // (done via class toggle to avoid interfering with any other dynamic style changes)\r\n    useEffect(() => {\r\n        if (dragState) {\r\n            document.body.classList.add('CSVImporter_dragging');\r\n        }\r\n        else {\r\n            // remove text selection prevention after a delay (otherwise on iOS it still selects something)\r\n            const timeoutId = setTimeout(() => {\r\n                document.body.classList.remove('CSVImporter_dragging');\r\n            }, 200);\r\n            return () => {\r\n                // if another drag state comes along then cancel our delay and just clean up class right away\r\n                clearTimeout(timeoutId);\r\n                document.body.classList.remove('CSVImporter_dragging');\r\n            };\r\n        }\r\n    }, [dragState]);\r\n    const columnSelectHandler = useCallback((column) => {\r\n        setDragState((prev) => {\r\n            // toggle off if needed\r\n            if (prev && prev.column === column) {\r\n                return null;\r\n            }\r\n            return {\r\n                pointerStartInfo: null,\r\n                column,\r\n                dropFieldName: null,\r\n                updateListeners: {}\r\n            };\r\n        });\r\n    }, []);\r\n    const dragHoverHandler = useCallback((fieldName, isOn) => {\r\n        setDragState((prev) => {\r\n            if (!prev) {\r\n                return prev;\r\n            }\r\n            if (isOn) {\r\n                // set the new drop target\r\n                return Object.assign(Object.assign({}, prev), { dropFieldName: fieldName });\r\n            }\r\n            else if (prev.dropFieldName === fieldName) {\r\n                // clear drop target if we are still the current one\r\n                return Object.assign(Object.assign({}, prev), { dropFieldName: null });\r\n            }\r\n            // no changes by default\r\n            return prev;\r\n        });\r\n    }, []);\r\n    const assignHandler = useCallback((fieldName) => {\r\n        // clear active drag state\r\n        setDragState(null);\r\n        if (dragState) {\r\n            internalAssignHandler(dragState.column, fieldName);\r\n        }\r\n    }, [internalAssignHandler, dragState]);\r\n    const unassignHandler = useCallback((column) => {\r\n        setFieldAssignments((prev) => {\r\n            const assignedFieldName = Object.keys(prev).find((fieldName) => prev[fieldName] === column.index);\r\n            if (assignedFieldName === undefined) {\r\n                return prev;\r\n            }\r\n            const copy = Object.assign({}, prev);\r\n            delete copy[assignedFieldName];\r\n            return copy;\r\n        });\r\n    }, []);\r\n    return {\r\n        fieldAssignments,\r\n        dragState,\r\n        dragEventBinder: bindDrag,\r\n        dragHoverHandler,\r\n        columnSelectHandler,\r\n        assignHandler,\r\n        unassignHandler\r\n    };\r\n}\r\n","import React, { useMemo } from 'react';\r\nimport { PREVIEW_ROW_COUNT } from '../../parser';\r\nimport './ColumnDragCard.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\n// @todo sort out \"grabbing\" cursor state (does not work with pointer-events:none)\r\nexport const ColumnDragCard = ({ hasHeaders, column: optionalColumn, rowCount = PREVIEW_ROW_COUNT, hasError, isAssigned, isShadow, isDraggable, isDragged, isDropIndicator }) => {\r\n    const isDummy = !optionalColumn;\r\n    const column = useMemo(() => optionalColumn || {\r\n        index: -1,\r\n        code: '',\r\n        header: hasHeaders ? '' : undefined,\r\n        values: [...new Array(PREVIEW_ROW_COUNT)].map(() => '')\r\n    }, [optionalColumn, hasHeaders]);\r\n    const headerValue = column.header;\r\n    const dataValues = column.values.slice(0, headerValue === undefined ? rowCount : rowCount - 1);\r\n    const l10n = useLocale('fieldsStep');\r\n    return (\r\n    // not changing variant dynamically because it causes a height jump\r\n    React.createElement(\"div\", { key: isDummy || isShadow ? 1 : isDropIndicator ? 2 : 0, className: \"CSVImporter_ColumnDragCard\", \"data-dummy\": !!isDummy, \"data-error\": !!hasError, \"data-shadow\": !!isShadow, \"data-draggable\": !!isDraggable, \"data-dragged\": !!isDragged, \"data-drop-indicator\": !!isDropIndicator },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragCard__cardHeader\" },\r\n            isDummy ? (React.createElement(\"var\", { role: \"text\" }, l10n.columnCardDummyHeader)) : (React.createElement(\"var\", { role: \"text\" }, l10n.getColumnCardHeader(column.code))),\r\n            isDummy || isAssigned ? '\\u00a0' : React.createElement(\"b\", { \"aria-hidden\": true }, column.code)),\r\n        headerValue !== undefined ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragCard__cardValue\", \"data-header\": true }, headerValue || '\\u00a0')) : null,\r\n        React.createElement(\"div\", { role: \"text\" }, dataValues.map((value, valueIndex) => (React.createElement(\"div\", { key: valueIndex, className: \"CSVImporter_ColumnDragCard__cardValue\" }, value || '\\u00a0'))))));\r\n};\r\n","import React, { useRef, useLayoutEffect } from 'react';\r\nimport { createPortal } from 'react-dom';\r\nimport { ColumnDragCard } from './ColumnDragCard';\r\nimport './ColumnDragObject.scss';\r\nexport const ColumnDragObject = ({ dragState }) => {\r\n    const referenceBoxRef = useRef(null);\r\n    // @todo wrap in a no-events overlay to clip against screen edges\r\n    const dragBoxRef = useRef(null);\r\n    const dragObjectPortal = dragState && dragState.pointerStartInfo\r\n        ? createPortal(React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject\" },\r\n            React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject__positioner\", ref: dragBoxRef },\r\n                React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject__holder\" },\r\n                    React.createElement(ColumnDragCard, { column: dragState.column, isDragged: true })))), document.body)\r\n        : null;\r\n    // set up initial position\r\n    const pointerStartInfo = dragState && dragState.pointerStartInfo;\r\n    useLayoutEffect(() => {\r\n        if (!pointerStartInfo || !dragBoxRef.current) {\r\n            return;\r\n        }\r\n        const { initialXY, initialWidth } = pointerStartInfo;\r\n        dragBoxRef.current.style.left = `${initialXY[0]}px`;\r\n        dragBoxRef.current.style.top = `${initialXY[1]}px`;\r\n        dragBoxRef.current.style.width = `${initialWidth}px`;\r\n        // copy known font style from main content\r\n        // @todo consider other text style properties?\r\n        if (referenceBoxRef.current) {\r\n            const computedStyle = window.getComputedStyle(referenceBoxRef.current);\r\n            dragBoxRef.current.style.fontFamily = computedStyle.fontFamily;\r\n            dragBoxRef.current.style.fontSize = computedStyle.fontSize;\r\n            dragBoxRef.current.style.fontWeight = computedStyle.fontWeight;\r\n            dragBoxRef.current.style.fontStyle = computedStyle.fontStyle;\r\n            dragBoxRef.current.style.letterSpacing = computedStyle.letterSpacing;\r\n        }\r\n    }, [pointerStartInfo]);\r\n    // subscribe to live position updates without state changes\r\n    useLayoutEffect(() => {\r\n        if (dragState) {\r\n            dragState.updateListeners['dragObj'] = (xy) => {\r\n                if (!dragBoxRef.current) {\r\n                    return;\r\n                }\r\n                dragBoxRef.current.style.left = `${xy[0]}px`;\r\n                dragBoxRef.current.style.top = `${xy[1]}px`;\r\n            };\r\n        }\r\n    }, [dragState]);\r\n    return React.createElement(\"div\", { ref: referenceBoxRef }, dragObjectPortal);\r\n};\r\n","import React, { useState, useMemo } from 'react';\r\nimport { ColumnDragCard } from './ColumnDragCard';\r\nimport { IconButton } from '../IconButton';\r\nimport './ColumnDragSourceArea.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nconst SOURCES_PAGE_SIZE = 5; // fraction of 10 for easier counting\r\n// @todo readable status text if not mouse-drag\r\nconst SourceBox = ({ column, fieldAssignments, dragState, eventBinder, onSelect, onUnassign }) => {\r\n    const isDragged = dragState ? column === dragState.column : false;\r\n    const isAssigned = useMemo(() => Object.keys(fieldAssignments).some((fieldName) => fieldAssignments[fieldName] === column.index), [fieldAssignments, column]);\r\n    const eventHandlers = useMemo(() => eventBinder(column), [\r\n        eventBinder,\r\n        column\r\n    ]);\r\n    const l10n = useLocale('fieldsStep');\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__box\" },\r\n        React.createElement(\"div\", Object.assign({}, (isAssigned ? {} : eventHandlers)),\r\n            React.createElement(ColumnDragCard, { column: column, isAssigned: isAssigned, isShadow: isDragged || isAssigned, isDraggable: !dragState && !isDragged && !isAssigned })),\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__boxAction\" }, isAssigned ? (React.createElement(IconButton, { key: \"clear\" // key-prop helps clear focus on click\r\n            , label: l10n.clearAssignmentTooltip, small: true, type: \"replay\", onClick: () => {\r\n                onUnassign(column);\r\n            } })) : (React.createElement(IconButton, { key: \"dragSelect\" // key-prop helps clear focus on click\r\n            , focusOnly: true, label: dragState && dragState.column === column\r\n                ? l10n.unselectColumnTooltip\r\n                : l10n.selectColumnTooltip, small: true, type: \"back\", onClick: () => {\r\n                onSelect(column);\r\n            } })))));\r\n};\r\n// @todo current page indicator (dots)\r\nexport const ColumnDragSourceArea = ({ columns, fieldAssignments, dragState, eventBinder, onSelect, onUnassign }) => {\r\n    const [page, setPage] = useState(0);\r\n    const [pageChanged, setPageChanged] = useState(false);\r\n    const pageCount = Math.ceil(columns.length / SOURCES_PAGE_SIZE);\r\n    const start = page * SOURCES_PAGE_SIZE;\r\n    const pageContents = columns\r\n        .slice(start, start + SOURCES_PAGE_SIZE)\r\n        .map((column, columnIndex) => (React.createElement(SourceBox, { key: columnIndex, column: column, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: eventBinder, onSelect: onSelect, onUnassign: onUnassign })));\r\n    while (pageContents.length < SOURCES_PAGE_SIZE) {\r\n        pageContents.push(React.createElement(\"div\", { key: pageContents.length, className: \"CSVImporter_ColumnDragSourceArea__pageFiller\" }));\r\n    }\r\n    const l10n = useLocale('fieldsStep');\r\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragSourceArea\", \"aria-label\": l10n.dragSourceAreaCaption },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__control\" },\r\n            React.createElement(IconButton, { label: l10n.previousColumnsTooltip, type: \"back\", disabled: page === 0, onClick: () => {\r\n                    setPage((prev) => Math.max(0, prev - 1));\r\n                    setPageChanged(true);\r\n                } })),\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__page\" },\r\n            dragState && !dragState.pointerStartInfo ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\", role: \"status\" }, l10n.getDragSourceActiveStatus(dragState.column.code))) : (\r\n            // show page number if needed (and treat as status role if it has changed)\r\n            // @todo changing role to status does not seem to work\r\n            pageCount > 1 && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\", role: pageChanged ? 'status' : 'text' }, l10n.getDragSourcePageIndicator(page + 1, pageCount)))),\r\n            pageContents),\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__control\" },\r\n            React.createElement(IconButton, { label: l10n.nextColumnsTooltip, type: \"forward\", disabled: page === pageCount - 1, onClick: () => {\r\n                    setPage((prev) => Math.min(pageCount - 1, prev + 1));\r\n                } }))));\r\n};\r\n","import React, { useMemo, useEffect, useRef } from 'react';\r\nimport { ColumnDragCard } from './ColumnDragCard';\r\nimport { IconButton } from '../IconButton';\r\nimport './ColumnDragTargetArea.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nconst TargetBox = ({ hasHeaders, field, touched, assignedColumn, dragState, eventBinder, onHover, onAssign, onUnassign }) => {\r\n    // wrap in ref to avoid re-triggering effect\r\n    const onHoverRef = useRef(onHover);\r\n    onHoverRef.current = onHover;\r\n    // respond to hover events when there is active mouse drag happening\r\n    // (not keyboard-emulated one)\r\n    const containerRef = useRef(null);\r\n    const isHoveredRef = useRef(false); // simple tracking of current hover state to avoid spamming onHover (not for display)\r\n    useEffect(() => {\r\n        const container = containerRef.current;\r\n        if (!dragState || !dragState.pointerStartInfo || !container) {\r\n            return;\r\n        }\r\n        // measure the current scroll-independent position\r\n        const rect = container.getBoundingClientRect();\r\n        const minX = rect.x;\r\n        const maxX = rect.x + rect.width;\r\n        const minY = rect.y;\r\n        const maxY = rect.y + rect.height;\r\n        // listen for pointer movement (mouse or touch) and detect hover\r\n        const listeners = dragState.updateListeners;\r\n        const listenerName = `field:${field.name}`;\r\n        listeners[listenerName] = (xy) => {\r\n            const isInBounds = xy[0] >= minX && xy[0] < maxX && xy[1] >= minY && xy[1] < maxY;\r\n            if (isInBounds !== isHoveredRef.current) {\r\n                // cannot use local var for isHovered state because the effect re-triggers after this\r\n                isHoveredRef.current = isInBounds;\r\n                onHoverRef.current(field.name, isInBounds);\r\n            }\r\n        };\r\n        // cleanup\r\n        return () => {\r\n            delete listeners[listenerName];\r\n        };\r\n    }, [dragState, field.name]);\r\n    // if this field is the current highlighted drop target,\r\n    // get the originating column data for display\r\n    const sourceColumn = dragState && dragState.dropFieldName === field.name\r\n        ? dragState.column\r\n        : null;\r\n    // see if currently assigned column is being dragged again\r\n    const isReDragged = dragState ? dragState.column === assignedColumn : false;\r\n    // drag start handlers for columns that can be re-dragged (i.e. are assigned)\r\n    const dragStartHandlers = useMemo(() => assignedColumn && !isReDragged\r\n        ? eventBinder(assignedColumn, field.name)\r\n        : {}, [eventBinder, assignedColumn, isReDragged, field.name]);\r\n    const valueContents = useMemo(() => {\r\n        if (sourceColumn) {\r\n            return (React.createElement(ColumnDragCard, { rowCount: 3, column: sourceColumn, isDropIndicator: true }));\r\n        }\r\n        if (assignedColumn) {\r\n            return (React.createElement(ColumnDragCard, { rowCount: 3, column: assignedColumn, isShadow: isReDragged, isDraggable: !isReDragged }));\r\n        }\r\n        const hasError = touched && !field.isOptional;\r\n        return (React.createElement(ColumnDragCard, { rowCount: 3, hasHeaders: hasHeaders, hasError: hasError }));\r\n    }, [hasHeaders, field, touched, assignedColumn, sourceColumn, isReDragged]);\r\n    const l10n = useLocale('fieldsStep');\r\n    // @todo mouse cursor changes to reflect draggable state\r\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragTargetArea__box\", \"aria-label\": field.isOptional\r\n            ? l10n.getDragTargetOptionalCaption(field.label)\r\n            : l10n.getDragTargetRequiredCaption(field.label), ref: containerRef },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxLabel\", \"aria-hidden\": true },\r\n            field.label,\r\n            field.isOptional ? null : React.createElement(\"b\", null, \"*\")),\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValue\" },\r\n            !sourceColumn && !assignedColumn && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxPlaceholderHelp\", \"aria-hidden\": true }, l10n.dragTargetPlaceholder)),\r\n            React.createElement(\"div\", Object.assign({}, dragStartHandlers), valueContents),\r\n            dragState && !dragState.pointerStartInfo ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\" },\r\n                React.createElement(IconButton, { label: l10n.getDragTargetAssignTooltip(dragState.column.code), small: true, type: \"forward\", onClick: () => onAssign(field.name) }))) : (!sourceColumn &&\r\n                assignedColumn && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\" },\r\n                React.createElement(IconButton, { label: l10n.dragTargetClearTooltip, small: true, type: \"close\", onClick: () => onUnassign(assignedColumn) })))))));\r\n};\r\nexport const ColumnDragTargetArea = ({ hasHeaders, fields, columns, fieldTouched, fieldAssignments, dragState, eventBinder, onHover, onAssign, onUnassign }) => {\r\n    const l10n = useLocale('fieldsStep');\r\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragTargetArea\", \"aria-label\": l10n.dragTargetAreaCaption }, fields.map((field) => {\r\n        const assignedColumnIndex = fieldAssignments[field.name];\r\n        return (React.createElement(TargetBox, { key: field.name, field: field, touched: fieldTouched[field.name], hasHeaders: hasHeaders, assignedColumn: assignedColumnIndex !== undefined\r\n                ? columns[assignedColumnIndex]\r\n                : null, dragState: dragState, eventBinder: eventBinder, onHover: onHover, onAssign: onAssign, onUnassign: onUnassign }));\r\n    })));\r\n};\r\n","import React, { useState, useMemo, useEffect, useRef } from 'react';\r\nimport { ImporterFrame } from '../ImporterFrame';\r\nimport { generatePreviewColumns, generateColumnCode } from './ColumnPreview';\r\nimport { useColumnDragState } from './ColumnDragState';\r\nimport { ColumnDragObject } from './ColumnDragObject';\r\nimport { ColumnDragSourceArea } from './ColumnDragSourceArea';\r\nimport { ColumnDragTargetArea } from './ColumnDragTargetArea';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nexport const FieldsStep = ({ fileState, fields, prevState, onChange, onAccept, onCancel }) => {\r\n    const onChangeRef = useRef(onChange);\r\n    onChangeRef.current = onChange;\r\n    const columns = useMemo(() => generatePreviewColumns(fileState.firstRows, fileState.hasHeaders).map((item) => (Object.assign(Object.assign({}, item), { code: generateColumnCode(item.index) }))), [fileState]);\r\n    const initialAssignments = useMemo(() => {\r\n        // prep insensitive/fuzzy match stems for known columns\r\n        // (this is ignored if there is already previous state to seed from)\r\n        const columnStems = columns.map((column) => {\r\n            const trimmed = column.header && column.header.trim();\r\n            if (!trimmed) {\r\n                return undefined;\r\n            }\r\n            return trimmed.toLowerCase();\r\n        });\r\n        // pre-assign corresponding fields\r\n        const result = {};\r\n        const assignedColumnIndexes = [];\r\n        fields.forEach((field) => {\r\n            // find by field stem\r\n            const fieldLabelStem = field.label.trim().toLowerCase(); // @todo consider normalizing other whitespace/non-letters\r\n            const matchingColumnIndex = columnStems.findIndex((columnStem, columnIndex) => {\r\n                // no headers or no meaningful stem value\r\n                if (columnStem === undefined) {\r\n                    return false;\r\n                }\r\n                // always check against assigning twice\r\n                if (assignedColumnIndexes[columnIndex]) {\r\n                    return false;\r\n                }\r\n                return columnStem === fieldLabelStem;\r\n            });\r\n            // assign if found\r\n            if (matchingColumnIndex !== -1) {\r\n                assignedColumnIndexes[matchingColumnIndex] = true;\r\n                result[field.name] = matchingColumnIndex;\r\n            }\r\n        });\r\n        return result;\r\n    }, [fields, columns]);\r\n    // track which fields need to show validation warning\r\n    const [fieldTouched, setFieldTouched] = useState({});\r\n    const [validationError, setValidationError] = useState(null);\r\n    const { fieldAssignments, dragState, dragEventBinder, dragHoverHandler, columnSelectHandler, assignHandler, unassignHandler } = useColumnDragState(fields, prevState ? prevState.fieldAssignments : initialAssignments, (fieldName) => {\r\n        setFieldTouched((prev) => {\r\n            if (prev[fieldName]) {\r\n                return prev;\r\n            }\r\n            const copy = Object.assign({}, prev);\r\n            copy[fieldName] = true;\r\n            return copy;\r\n        });\r\n    });\r\n    // notify of current state\r\n    useEffect(() => {\r\n        onChangeRef.current({ fieldAssignments: Object.assign({}, fieldAssignments) });\r\n    }, [fieldAssignments]);\r\n    const l10n = useLocale('fieldsStep');\r\n    return (React.createElement(ImporterFrame, { fileName: fileState.file.name, subtitle: l10n.stepSubtitle, error: validationError, onCancel: onCancel, onNext: () => {\r\n            // mark all fields as touched\r\n            const fullTouchedMap = {};\r\n            fields.some((field) => {\r\n                fullTouchedMap[field.name] = true;\r\n            });\r\n            setFieldTouched(fullTouchedMap);\r\n            // submit if validation succeeds\r\n            const hasUnassignedRequired = fields.some((field) => !field.isOptional && fieldAssignments[field.name] === undefined);\r\n            if (!hasUnassignedRequired) {\r\n                onAccept();\r\n            }\r\n            else {\r\n                setValidationError(l10n.requiredFieldsError);\r\n            }\r\n        }, nextLabel: l10n.nextButton },\r\n        React.createElement(ColumnDragSourceArea, { columns: columns, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: dragEventBinder, onSelect: columnSelectHandler, onUnassign: unassignHandler }),\r\n        React.createElement(ColumnDragTargetArea, { hasHeaders: fileState.hasHeaders, fields: fields, columns: columns, fieldTouched: fieldTouched, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: dragEventBinder, onHover: dragHoverHandler, onAssign: assignHandler, onUnassign: unassignHandler }),\r\n        React.createElement(ColumnDragObject, { dragState: dragState })));\r\n};\r\n","import React, { useState, useEffect, useMemo, useRef } from 'react';\r\nimport { processFile } from '../parser';\r\nimport { ImporterFrame } from './ImporterFrame';\r\nimport './ProgressDisplay.scss';\r\nimport { useLocale } from '../locale/LocaleContext';\r\n// compute actual UTF-8 bytes used by a string\r\n// (inspired by https://stackoverflow.com/questions/10576905/how-to-convert-javascript-unicode-notation-code-to-utf-8)\r\nfunction countUTF8Bytes(item) {\r\n    // re-encode into UTF-8\r\n    const escaped = encodeURIComponent(item);\r\n    // convert byte escape sequences into single characters\r\n    const normalized = escaped.replace(/%\\d\\d/g, '_');\r\n    return normalized.length;\r\n}\r\nexport function ProgressDisplay({ fileState, fieldsState, externalPreview, processChunk, onStart, onComplete, onRestart, onClose }) {\r\n    const [progressCount, setProgressCount] = useState(0);\r\n    const [isComplete, setIsComplete] = useState(false);\r\n    const [error, setError] = useState(null);\r\n    const [isDismissed, setIsDismissed] = useState(false); // prevents double-clicking finish\r\n    // info object exposed to the progress callbacks\r\n    const importInfo = useMemo(() => {\r\n        const fieldList = Object.keys(fieldsState.fieldAssignments);\r\n        const columnSparseList = [];\r\n        fieldList.forEach((field) => {\r\n            const col = fieldsState.fieldAssignments[field];\r\n            if (col !== undefined) {\r\n                columnSparseList[col] = field;\r\n            }\r\n        });\r\n        return {\r\n            file: fileState.file,\r\n            preview: externalPreview,\r\n            fields: fieldList,\r\n            columnFields: [...columnSparseList]\r\n        };\r\n    }, [fileState, fieldsState, externalPreview]);\r\n    // estimate number of rows\r\n    const estimatedRowCount = useMemo(() => {\r\n        // sum up sizes of all the parsed preview rows and get estimated average\r\n        const totalPreviewRowBytes = fileState.firstRows.reduce((prevCount, row) => {\r\n            const rowBytes = row.reduce((prev, item) => {\r\n                return prev + countUTF8Bytes(item) + 1; // add a byte for separator or newline\r\n            }, 0);\r\n            return prevCount + rowBytes;\r\n        }, 0);\r\n        const averagePreviewRowSize = totalPreviewRowBytes / fileState.firstRows.length;\r\n        // divide file size by estimated row size (or fall back to a sensible amount)\r\n        return averagePreviewRowSize > 1\r\n            ? fileState.file.size / averagePreviewRowSize\r\n            : 100;\r\n    }, [fileState]);\r\n    // notify on start of processing\r\n    // (separate effect in case of errors)\r\n    const onStartRef = useRef(onStart); // wrap in ref to avoid re-triggering (only first instance is needed)\r\n    useEffect(() => {\r\n        if (onStartRef.current) {\r\n            onStartRef.current(importInfo);\r\n        }\r\n    }, [importInfo]);\r\n    // notify on end of processing\r\n    // (separate effect in case of errors)\r\n    const onCompleteRef = useRef(onComplete); // wrap in ref to avoid re-triggering\r\n    onCompleteRef.current = onComplete;\r\n    useEffect(() => {\r\n        if (isComplete && onCompleteRef.current) {\r\n            onCompleteRef.current(importInfo);\r\n        }\r\n    }, [importInfo, isComplete]);\r\n    // ensure status gets focus when complete, in case status role is not read out\r\n    const statusRef = useRef(null);\r\n    useEffect(() => {\r\n        if ((isComplete || error) && statusRef.current) {\r\n            statusRef.current.focus();\r\n        }\r\n    }, [isComplete, error]);\r\n    // perform main async parse\r\n    const processChunkRef = useRef(processChunk); // wrap in ref to avoid re-triggering\r\n    const asyncLockRef = useRef(0);\r\n    useEffect(() => {\r\n        const oplock = asyncLockRef.current;\r\n        processFile(Object.assign(Object.assign({}, fileState), { fieldAssignments: fieldsState.fieldAssignments }), (deltaCount) => {\r\n            // ignore if stale\r\n            if (oplock !== asyncLockRef.current) {\r\n                return; // @todo signal abort\r\n            }\r\n            setProgressCount((prev) => prev + deltaCount);\r\n        }, processChunkRef.current).then(() => {\r\n            // ignore if stale\r\n            if (oplock !== asyncLockRef.current) {\r\n                return;\r\n            }\r\n            setIsComplete(true);\r\n        }, (error) => {\r\n            // ignore if stale\r\n            if (oplock !== asyncLockRef.current) {\r\n                return;\r\n            }\r\n            setError(error);\r\n        });\r\n        return () => {\r\n            // invalidate current oplock on change or unmount\r\n            asyncLockRef.current += 1;\r\n        };\r\n    }, [fileState, fieldsState]);\r\n    // simulate asymptotic progress percentage\r\n    const progressPercentage = useMemo(() => {\r\n        if (isComplete) {\r\n            return 100;\r\n        }\r\n        // inputs hand-picked so that correctly estimated total is about 75% of the bar\r\n        const progressPower = 2.5 * (progressCount / estimatedRowCount);\r\n        const progressLeft = Math.pow(0.5, progressPower);\r\n        // convert to .1 percent precision for smoother bar display\r\n        return Math.floor(1000 - 1000 * progressLeft) / 10;\r\n    }, [estimatedRowCount, progressCount, isComplete]);\r\n    const l10n = useLocale('progressStep');\r\n    return (React.createElement(ImporterFrame, { fileName: fileState.file.name, subtitle: l10n.stepSubtitle, error: error && (error.message || String(error)), secondaryDisabled: !isComplete || isDismissed, secondaryLabel: onRestart && onClose ? l10n.uploadMoreButton : undefined, onSecondary: onRestart && onClose ? onRestart : undefined, nextDisabled: !isComplete || isDismissed, nextLabel: !!(onClose || onRestart) &&\r\n            (onRestart ? l10n.uploadMoreButton : l10n.finishButton), onNext: () => {\r\n            if (onClose) {\r\n                setIsDismissed(true);\r\n                onClose(importInfo);\r\n            }\r\n            else if (onRestart) {\r\n                onRestart();\r\n            }\r\n        } },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay\" },\r\n            isComplete || error ? (React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__status\", role: \"status\", tabIndex: -1, ref: statusRef }, error ? l10n.statusError : l10n.statusComplete)) : (React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__status -pending\", role: \"status\" }, l10n.statusPending)),\r\n            React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__count\", role: \"text\" },\r\n                React.createElement(\"var\", null, l10n.processedRowsLabel),\r\n                \" \",\r\n                progressCount),\r\n            React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__progressBar\" },\r\n                React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__progressBarIndicator\", style: { width: `${progressPercentage}%` } })))));\r\n}\r\n","var __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nimport React, { useMemo, useState, useEffect, useContext } from 'react';\r\nimport { FileStep } from './file-step/FileStep';\r\nimport { generatePreviewColumns } from './fields-step/ColumnPreview';\r\nimport { FieldsStep } from './fields-step/FieldsStep';\r\nimport { ProgressDisplay } from './ProgressDisplay';\r\nimport './Importer.scss';\r\nimport { LocaleContext } from '../locale/LocaleContext';\r\nimport { enUS } from '../locale';\r\nconst FieldDefinitionContext = React.createContext(null);\r\nlet fieldIdCount = 0;\r\n// defines a field to be filled from file column during import\r\nexport const ImporterField = ({ name, label, optional }) => {\r\n    // @todo this is not SSR-compatible\r\n    const fieldId = useMemo(() => (fieldIdCount += 1), []);\r\n    const fieldSetter = useContext(FieldDefinitionContext);\r\n    // update central list as needed\r\n    useEffect(() => {\r\n        if (!fieldSetter) {\r\n            console.error('importer field must be a child of importer'); // @todo\r\n            return;\r\n        }\r\n        fieldSetter((prev) => {\r\n            const newField = { id: fieldId, name, label, isOptional: !!optional };\r\n            const copy = [...prev];\r\n            const existingIndex = copy.findIndex((item) => item.name === name);\r\n            // preserve existing array position if possible\r\n            // @todo keep both copies in a map to deal with dynamic fields better\r\n            if (existingIndex === -1) {\r\n                copy.push(newField);\r\n            }\r\n            else {\r\n                copy[existingIndex] = newField;\r\n            }\r\n            return copy;\r\n        });\r\n    }, [fieldId, fieldSetter, name, label, optional]);\r\n    // on component unmount, remove this field from list by ID\r\n    useEffect(() => {\r\n        if (!fieldSetter) {\r\n            console.error('importer field must be a child of importer'); // @todo\r\n            return;\r\n        }\r\n        return () => {\r\n            fieldSetter((prev) => {\r\n                return prev.filter((field) => field.id !== fieldId);\r\n            });\r\n        };\r\n    }, [fieldId, fieldSetter]);\r\n    return null;\r\n};\r\nexport function Importer(_a) {\r\n    var { assumeNoHeaders, restartable, processChunk, onStart, onComplete, onClose, children: content, locale } = _a, customPapaParseConfig = __rest(_a, [\"assumeNoHeaders\", \"restartable\", \"processChunk\", \"onStart\", \"onComplete\", \"onClose\", \"children\", \"locale\"]);\r\n    // helper to combine our displayed content and the user code that provides field definitions\r\n    const [fields, setFields] = useState([]);\r\n    const [fileState, setFileState] = useState(null);\r\n    const [fileAccepted, setFileAccepted] = useState(false);\r\n    const [fieldsState, setFieldsState] = useState(null);\r\n    const [fieldsAccepted, setFieldsAccepted] = useState(false);\r\n    // reset field assignments when file changes\r\n    const activeFile = fileState && fileState.file;\r\n    useEffect(() => {\r\n        if (activeFile) {\r\n            setFieldsState(null);\r\n        }\r\n    }, [activeFile]);\r\n    const externalPreview = useMemo(() => {\r\n        // generate stable externally-visible data objects\r\n        const externalColumns = fileState &&\r\n            generatePreviewColumns(fileState.firstRows, fileState.hasHeaders);\r\n        return (fileState &&\r\n            externalColumns && {\r\n            rawData: fileState.firstChunk,\r\n            columns: externalColumns,\r\n            skipHeaders: !fileState.hasHeaders,\r\n            parseWarning: fileState.parseWarning\r\n        });\r\n    }, [fileState]);\r\n    // render provided child content that defines the fields\r\n    const contentNodes = useMemo(() => {\r\n        return typeof content === 'function'\r\n            ? content({\r\n                file: fileState && fileState.file,\r\n                preview: externalPreview\r\n            })\r\n            : content;\r\n    }, [fileState, externalPreview, content]);\r\n    const contentWrap = (React.createElement(FieldDefinitionContext.Provider, { value: setFields }, contentNodes));\r\n    // fall back to enUS if no default locale provided\r\n    locale = locale !== null && locale !== void 0 ? locale : enUS;\r\n    if (!fileAccepted || fileState === null || externalPreview === null) {\r\n        return (React.createElement(LocaleContext.Provider, { value: locale },\r\n            React.createElement(\"div\", { className: \"CSVImporter_Importer\" },\r\n                React.createElement(FileStep, { customConfig: customPapaParseConfig, assumeNoHeaders: assumeNoHeaders, prevState: fileState, onChange: (parsedPreview) => {\r\n                        setFileState(parsedPreview);\r\n                    }, onAccept: () => {\r\n                        setFileAccepted(true);\r\n                    } }),\r\n                contentWrap)));\r\n    }\r\n    if (!fieldsAccepted || fieldsState === null) {\r\n        return (React.createElement(LocaleContext.Provider, { value: locale },\r\n            React.createElement(\"div\", { className: \"CSVImporter_Importer\" },\r\n                React.createElement(FieldsStep, { fileState: fileState, fields: fields, prevState: fieldsState, onChange: (state) => {\r\n                        setFieldsState(state);\r\n                    }, onAccept: () => {\r\n                        setFieldsAccepted(true);\r\n                    }, onCancel: () => {\r\n                        // keep existing preview data and assignments\r\n                        setFileAccepted(false);\r\n                    } }),\r\n                contentWrap)));\r\n    }\r\n    return (React.createElement(LocaleContext.Provider, { value: locale },\r\n        React.createElement(\"div\", { className: \"CSVImporter_Importer\" },\r\n            React.createElement(ProgressDisplay, { fileState: fileState, fieldsState: fieldsState, externalPreview: externalPreview, processChunk: processChunk, onStart: onStart, onRestart: restartable\r\n                    ? () => {\r\n                        // reset all state\r\n                        setFileState(null);\r\n                        setFileAccepted(false);\r\n                        setFieldsState(null);\r\n                        setFieldsAccepted(false);\r\n                    }\r\n                    : undefined, onComplete: onComplete, onClose: onClose }),\r\n            contentWrap)));\r\n}\r\n"]},"metadata":{},"sourceType":"script"}